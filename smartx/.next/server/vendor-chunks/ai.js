"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ai";
exports.ids = ["vendor-chunks/ai"];
exports.modules = {

/***/ "(ssr)/./node_modules/ai/node_modules/nanoid/non-secure/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ai/node_modules/nanoid/non-secure/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   customAlphabet: () => (/* binding */ customAlphabet),\n/* harmony export */   nanoid: () => (/* binding */ nanoid)\n/* harmony export */ });\nlet urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nlet customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    let i = size\n    while (i--) {\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\nlet nanoid = (size = 21) => {\n  let id = ''\n  let i = size\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWkvbm9kZV9tb2R1bGVzL25hbm9pZC9ub24tc2VjdXJlL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0eC8uL25vZGVfbW9kdWxlcy9haS9ub2RlX21vZHVsZXMvbmFub2lkL25vbi1zZWN1cmUvaW5kZXguanM/Y2M1YSJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgdXJsQWxwaGFiZXQgPVxuICAndXNlYW5kb20tMjZUMTk4MzQwUFg3NXB4SkFDS1ZFUllNSU5EQlVTSFdPTEZfR1FaYmZnaGprbHF2d3l6cmljdCdcbmxldCBjdXN0b21BbHBoYWJldCA9IChhbHBoYWJldCwgZGVmYXVsdFNpemUgPSAyMSkgPT4ge1xuICByZXR1cm4gKHNpemUgPSBkZWZhdWx0U2l6ZSkgPT4ge1xuICAgIGxldCBpZCA9ICcnXG4gICAgbGV0IGkgPSBzaXplXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgaWQgKz0gYWxwaGFiZXRbKE1hdGgucmFuZG9tKCkgKiBhbHBoYWJldC5sZW5ndGgpIHwgMF1cbiAgICB9XG4gICAgcmV0dXJuIGlkXG4gIH1cbn1cbmxldCBuYW5vaWQgPSAoc2l6ZSA9IDIxKSA9PiB7XG4gIGxldCBpZCA9ICcnXG4gIGxldCBpID0gc2l6ZVxuICB3aGlsZSAoaS0tKSB7XG4gICAgaWQgKz0gdXJsQWxwaGFiZXRbKE1hdGgucmFuZG9tKCkgKiA2NCkgfCAwXVxuICB9XG4gIHJldHVybiBpZFxufVxuZXhwb3J0IHsgbmFub2lkLCBjdXN0b21BbHBoYWJldCB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ai/node_modules/nanoid/non-secure/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ai/react/dist/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/ai/react/dist/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   experimental_useAssistant: () => (/* binding */ experimental_useAssistant),\n/* harmony export */   useAssistant: () => (/* binding */ useAssistant),\n/* harmony export */   useChat: () => (/* binding */ useChat),\n/* harmony export */   useCompletion: () => (/* binding */ useCompletion)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! swr */ \"(ssr)/./node_modules/swr/core/dist/index.mjs\");\n/* harmony import */ var nanoid_non_secure__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! nanoid/non-secure */ \"(ssr)/./node_modules/ai/node_modules/nanoid/non-secure/index.js\");\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(ssr)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* __next_internal_client_entry_do_not_use__ experimental_useAssistant,useAssistant,useChat,useCompletion auto */ // react/use-chat.ts\n\n\n// shared/generate-id.ts\n\nvar generateId = (0,nanoid_non_secure__WEBPACK_IMPORTED_MODULE_2__.customAlphabet)(\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\", 7);\n// shared/stream-parts.ts\nvar textStreamPart = {\n    code: \"0\",\n    name: \"text\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"text\" parts expect a string value.');\n        }\n        return {\n            type: \"text\",\n            value\n        };\n    }\n};\nvar functionCallStreamPart = {\n    code: \"1\",\n    name: \"function_call\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"function_call\" in value) || typeof value.function_call !== \"object\" || value.function_call == null || !(\"name\" in value.function_call) || !(\"arguments\" in value.function_call) || typeof value.function_call.name !== \"string\" || typeof value.function_call.arguments !== \"string\") {\n            throw new Error('\"function_call\" parts expect an object with a \"function_call\" property.');\n        }\n        return {\n            type: \"function_call\",\n            value\n        };\n    }\n};\nvar dataStreamPart = {\n    code: \"2\",\n    name: \"data\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"data\" parts expect an array value.');\n        }\n        return {\n            type: \"data\",\n            value\n        };\n    }\n};\nvar errorStreamPart = {\n    code: \"3\",\n    name: \"error\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"error\" parts expect a string value.');\n        }\n        return {\n            type: \"error\",\n            value\n        };\n    }\n};\nvar assistantMessageStreamPart = {\n    code: \"4\",\n    name: \"assistant_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"id\" in value) || !(\"role\" in value) || !(\"content\" in value) || typeof value.id !== \"string\" || typeof value.role !== \"string\" || value.role !== \"assistant\" || !Array.isArray(value.content) || !value.content.every((item)=>item != null && typeof item === \"object\" && \"type\" in item && item.type === \"text\" && \"text\" in item && item.text != null && typeof item.text === \"object\" && \"value\" in item.text && typeof item.text.value === \"string\")) {\n            throw new Error('\"assistant_message\" parts expect an object with an \"id\", \"role\", and \"content\" property.');\n        }\n        return {\n            type: \"assistant_message\",\n            value\n        };\n    }\n};\nvar assistantControlDataStreamPart = {\n    code: \"5\",\n    name: \"assistant_control_data\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"threadId\" in value) || !(\"messageId\" in value) || typeof value.threadId !== \"string\" || typeof value.messageId !== \"string\") {\n            throw new Error('\"assistant_control_data\" parts expect an object with a \"threadId\" and \"messageId\" property.');\n        }\n        return {\n            type: \"assistant_control_data\",\n            value: {\n                threadId: value.threadId,\n                messageId: value.messageId\n            }\n        };\n    }\n};\nvar dataMessageStreamPart = {\n    code: \"6\",\n    name: \"data_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"role\" in value) || !(\"data\" in value) || typeof value.role !== \"string\" || value.role !== \"data\") {\n            throw new Error('\"data_message\" parts expect an object with a \"role\" and \"data\" property.');\n        }\n        return {\n            type: \"data_message\",\n            value\n        };\n    }\n};\nvar toolCallsStreamPart = {\n    code: \"7\",\n    name: \"tool_calls\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"tool_calls\" in value) || typeof value.tool_calls !== \"object\" || value.tool_calls == null || !Array.isArray(value.tool_calls) || value.tool_calls.some((tc)=>tc == null || typeof tc !== \"object\" || !(\"id\" in tc) || typeof tc.id !== \"string\" || !(\"type\" in tc) || typeof tc.type !== \"string\" || !(\"function\" in tc) || tc.function == null || typeof tc.function !== \"object\" || !(\"arguments\" in tc.function) || typeof tc.function.name !== \"string\" || typeof tc.function.arguments !== \"string\")) {\n            throw new Error('\"tool_calls\" parts expect an object with a ToolCallPayload.');\n        }\n        return {\n            type: \"tool_calls\",\n            value\n        };\n    }\n};\nvar messageAnnotationsStreamPart = {\n    code: \"8\",\n    name: \"message_annotations\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"message_annotations\" parts expect an array value.');\n        }\n        return {\n            type: \"message_annotations\",\n            value\n        };\n    }\n};\nvar toolCallStreamPart = {\n    code: \"9\",\n    name: \"tool_call\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"toolName\" in value) || typeof value.toolName !== \"string\" || !(\"args\" in value) || typeof value.args !== \"object\") {\n            throw new Error('\"tool_call\" parts expect an object with a \"toolCallId\", \"toolName\", and \"args\" property.');\n        }\n        return {\n            type: \"tool_call\",\n            value\n        };\n    }\n};\nvar toolResultStreamPart = {\n    code: \"a\",\n    name: \"tool_result\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"toolName\" in value) || typeof value.toolName !== \"string\" || !(\"args\" in value) || typeof value.args !== \"object\" || !(\"result\" in value)) {\n            throw new Error('\"tool_result\" parts expect an object with a \"toolCallId\", \"toolName\", \"args\", and \"result\" property.');\n        }\n        return {\n            type: \"tool_result\",\n            value\n        };\n    }\n};\nvar streamParts = [\n    textStreamPart,\n    functionCallStreamPart,\n    dataStreamPart,\n    errorStreamPart,\n    assistantMessageStreamPart,\n    assistantControlDataStreamPart,\n    dataMessageStreamPart,\n    toolCallsStreamPart,\n    messageAnnotationsStreamPart,\n    toolCallStreamPart,\n    toolResultStreamPart\n];\nvar streamPartsByCode = {\n    [textStreamPart.code]: textStreamPart,\n    [functionCallStreamPart.code]: functionCallStreamPart,\n    [dataStreamPart.code]: dataStreamPart,\n    [errorStreamPart.code]: errorStreamPart,\n    [assistantMessageStreamPart.code]: assistantMessageStreamPart,\n    [assistantControlDataStreamPart.code]: assistantControlDataStreamPart,\n    [dataMessageStreamPart.code]: dataMessageStreamPart,\n    [toolCallsStreamPart.code]: toolCallsStreamPart,\n    [messageAnnotationsStreamPart.code]: messageAnnotationsStreamPart,\n    [toolCallStreamPart.code]: toolCallStreamPart,\n    [toolResultStreamPart.code]: toolResultStreamPart\n};\nvar StreamStringPrefixes = {\n    [textStreamPart.name]: textStreamPart.code,\n    [functionCallStreamPart.name]: functionCallStreamPart.code,\n    [dataStreamPart.name]: dataStreamPart.code,\n    [errorStreamPart.name]: errorStreamPart.code,\n    [assistantMessageStreamPart.name]: assistantMessageStreamPart.code,\n    [assistantControlDataStreamPart.name]: assistantControlDataStreamPart.code,\n    [dataMessageStreamPart.name]: dataMessageStreamPart.code,\n    [toolCallsStreamPart.name]: toolCallsStreamPart.code,\n    [messageAnnotationsStreamPart.name]: messageAnnotationsStreamPart.code,\n    [toolCallStreamPart.name]: toolCallStreamPart.code,\n    [toolResultStreamPart.name]: toolResultStreamPart.code\n};\nvar validCodes = streamParts.map((part)=>part.code);\nvar parseStreamPart = (line)=>{\n    const firstSeparatorIndex = line.indexOf(\":\");\n    if (firstSeparatorIndex === -1) {\n        throw new Error(\"Failed to parse stream string. No separator found.\");\n    }\n    const prefix = line.slice(0, firstSeparatorIndex);\n    if (!validCodes.includes(prefix)) {\n        throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n    }\n    const code = prefix;\n    const textValue = line.slice(firstSeparatorIndex + 1);\n    const jsonValue = JSON.parse(textValue);\n    return streamPartsByCode[code].parse(jsonValue);\n};\n// shared/read-data-stream.ts\nvar NEWLINE = \"\\n\".charCodeAt(0);\nfunction concatChunks(chunks, totalLength) {\n    const concatenatedChunks = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const chunk of chunks){\n        concatenatedChunks.set(chunk, offset);\n        offset += chunk.length;\n    }\n    chunks.length = 0;\n    return concatenatedChunks;\n}\nasync function* readDataStream(reader, { isAborted } = {}) {\n    const decoder = new TextDecoder();\n    const chunks = [];\n    let totalLength = 0;\n    while(true){\n        const { value } = await reader.read();\n        if (value) {\n            chunks.push(value);\n            totalLength += value.length;\n            if (value[value.length - 1] !== NEWLINE) {\n                continue;\n            }\n        }\n        if (chunks.length === 0) {\n            break;\n        }\n        const concatenatedChunks = concatChunks(chunks, totalLength);\n        totalLength = 0;\n        const streamParts2 = decoder.decode(concatenatedChunks, {\n            stream: true\n        }).split(\"\\n\").filter((line)=>line !== \"\").map(parseStreamPart);\n        for (const streamPart of streamParts2){\n            yield streamPart;\n        }\n        if (isAborted == null ? void 0 : isAborted()) {\n            reader.cancel();\n            break;\n        }\n    }\n}\n// shared/parse-complex-response.ts\nfunction assignAnnotationsToMessage(message, annotations) {\n    if (!message || !annotations || !annotations.length) return message;\n    return {\n        ...message,\n        annotations: [\n            ...annotations\n        ]\n    };\n}\nasync function parseComplexResponse({ reader, abortControllerRef, update, onFinish, generateId: generateId2 = generateId, getCurrentDate = ()=>/* @__PURE__ */ new Date() }) {\n    const createdAt = getCurrentDate();\n    const prefixMap = {\n        data: []\n    };\n    let message_annotations = void 0;\n    for await (const { type, value } of readDataStream(reader, {\n        isAborted: ()=>(abortControllerRef == null ? void 0 : abortControllerRef.current) === null\n    })){\n        if (type === \"text\") {\n            if (prefixMap[\"text\"]) {\n                prefixMap[\"text\"] = {\n                    ...prefixMap[\"text\"],\n                    content: (prefixMap[\"text\"].content || \"\") + value\n                };\n            } else {\n                prefixMap[\"text\"] = {\n                    id: generateId2(),\n                    role: \"assistant\",\n                    content: value,\n                    createdAt\n                };\n            }\n        }\n        if (type === \"tool_call\") {\n            if (prefixMap.text == null) {\n                prefixMap.text = {\n                    id: generateId2(),\n                    role: \"assistant\",\n                    content: \"\",\n                    createdAt\n                };\n            }\n            if (prefixMap.text.toolInvocations == null) {\n                prefixMap.text.toolInvocations = [];\n            }\n            prefixMap.text.toolInvocations.push(value);\n        } else if (type === \"tool_result\") {\n            if (prefixMap.text == null) {\n                prefixMap.text = {\n                    id: generateId2(),\n                    role: \"assistant\",\n                    content: \"\",\n                    createdAt\n                };\n            }\n            if (prefixMap.text.toolInvocations == null) {\n                prefixMap.text.toolInvocations = [];\n            }\n            const toolInvocationIndex = prefixMap.text.toolInvocations.findIndex((invocation)=>invocation.toolCallId === value.toolCallId);\n            if (toolInvocationIndex !== -1) {\n                prefixMap.text.toolInvocations[toolInvocationIndex] = value;\n            } else {\n                prefixMap.text.toolInvocations.push(value);\n            }\n        }\n        let functionCallMessage = null;\n        if (type === \"function_call\") {\n            prefixMap[\"function_call\"] = {\n                id: generateId2(),\n                role: \"assistant\",\n                content: \"\",\n                function_call: value.function_call,\n                name: value.function_call.name,\n                createdAt\n            };\n            functionCallMessage = prefixMap[\"function_call\"];\n        }\n        let toolCallMessage = null;\n        if (type === \"tool_calls\") {\n            prefixMap[\"tool_calls\"] = {\n                id: generateId2(),\n                role: \"assistant\",\n                content: \"\",\n                tool_calls: value.tool_calls,\n                createdAt\n            };\n            toolCallMessage = prefixMap[\"tool_calls\"];\n        }\n        if (type === \"data\") {\n            prefixMap[\"data\"].push(...value);\n        }\n        let responseMessage = prefixMap[\"text\"];\n        if (type === \"message_annotations\") {\n            if (!message_annotations) {\n                message_annotations = [\n                    ...value\n                ];\n            } else {\n                message_annotations.push(...value);\n            }\n            functionCallMessage = assignAnnotationsToMessage(prefixMap[\"function_call\"], message_annotations);\n            toolCallMessage = assignAnnotationsToMessage(prefixMap[\"tool_calls\"], message_annotations);\n            responseMessage = assignAnnotationsToMessage(prefixMap[\"text\"], message_annotations);\n        }\n        if (message_annotations == null ? void 0 : message_annotations.length) {\n            const messagePrefixKeys = [\n                \"text\",\n                \"function_call\",\n                \"tool_calls\"\n            ];\n            messagePrefixKeys.forEach((key)=>{\n                if (prefixMap[key]) {\n                    prefixMap[key].annotations = [\n                        ...message_annotations\n                    ];\n                }\n            });\n        }\n        const merged = [\n            functionCallMessage,\n            toolCallMessage,\n            responseMessage\n        ].filter(Boolean).map((message)=>({\n                ...assignAnnotationsToMessage(message, message_annotations)\n            }));\n        update(merged, [\n            ...prefixMap[\"data\"]\n        ]);\n    }\n    onFinish == null ? void 0 : onFinish(prefixMap);\n    return {\n        messages: [\n            prefixMap.text,\n            prefixMap.function_call,\n            prefixMap.tool_calls\n        ].filter(Boolean),\n        data: prefixMap.data\n    };\n}\n// shared/utils.ts\nfunction createChunkDecoder(complex) {\n    const decoder = new TextDecoder();\n    if (!complex) {\n        return function(chunk) {\n            if (!chunk) return \"\";\n            return decoder.decode(chunk, {\n                stream: true\n            });\n        };\n    }\n    return function(chunk) {\n        const decoded = decoder.decode(chunk, {\n            stream: true\n        }).split(\"\\n\").filter((line)=>line !== \"\");\n        return decoded.map(parseStreamPart).filter(Boolean);\n    };\n}\n// shared/call-chat-api.ts\nasync function callChatApi({ api, messages, body, streamMode = \"stream-data\", credentials, headers, abortController, restoreMessagesOnFailure, onResponse, onUpdate, onFinish, generateId: generateId2 }) {\n    var _a;\n    const response = await fetch(api, {\n        method: \"POST\",\n        body: JSON.stringify({\n            messages,\n            ...body\n        }),\n        headers: {\n            \"Content-Type\": \"application/json\",\n            ...headers\n        },\n        signal: (_a = abortController == null ? void 0 : abortController()) == null ? void 0 : _a.signal,\n        credentials\n    }).catch((err)=>{\n        restoreMessagesOnFailure();\n        throw err;\n    });\n    if (onResponse) {\n        try {\n            await onResponse(response);\n        } catch (err) {\n            throw err;\n        }\n    }\n    if (!response.ok) {\n        restoreMessagesOnFailure();\n        throw new Error(await response.text() || \"Failed to fetch the chat response.\");\n    }\n    if (!response.body) {\n        throw new Error(\"The response body is empty.\");\n    }\n    const reader = response.body.getReader();\n    switch(streamMode){\n        case \"text\":\n            {\n                const decoder = createChunkDecoder();\n                const resultMessage = {\n                    id: generateId2(),\n                    createdAt: /* @__PURE__ */ new Date(),\n                    role: \"assistant\",\n                    content: \"\"\n                };\n                while(true){\n                    const { done, value } = await reader.read();\n                    if (done) {\n                        break;\n                    }\n                    resultMessage.content += decoder(value);\n                    resultMessage.id = generateId2();\n                    onUpdate([\n                        {\n                            ...resultMessage\n                        }\n                    ], []);\n                    if ((abortController == null ? void 0 : abortController()) === null) {\n                        reader.cancel();\n                        break;\n                    }\n                }\n                onFinish == null ? void 0 : onFinish(resultMessage);\n                return {\n                    messages: [\n                        resultMessage\n                    ],\n                    data: []\n                };\n            }\n        case \"stream-data\":\n            {\n                return await parseComplexResponse({\n                    reader,\n                    abortControllerRef: abortController != null ? {\n                        current: abortController()\n                    } : void 0,\n                    update: onUpdate,\n                    onFinish (prefixMap) {\n                        if (onFinish && prefixMap.text != null) {\n                            onFinish(prefixMap.text);\n                        }\n                    },\n                    generateId: generateId2\n                });\n            }\n        default:\n            {\n                const exhaustiveCheck = streamMode;\n                throw new Error(`Unknown stream mode: ${exhaustiveCheck}`);\n            }\n    }\n}\n// shared/process-chat-stream.ts\nasync function processChatStream({ getStreamedResponse: getStreamedResponse2, experimental_onFunctionCall, experimental_onToolCall, updateChatRequest, getCurrentMessages }) {\n    while(true){\n        const messagesAndDataOrJustMessage = await getStreamedResponse2();\n        if (\"messages\" in messagesAndDataOrJustMessage) {\n            let hasFollowingResponse = false;\n            for (const message of messagesAndDataOrJustMessage.messages){\n                if ((message.function_call === void 0 || typeof message.function_call === \"string\") && (message.tool_calls === void 0 || typeof message.tool_calls === \"string\")) {\n                    continue;\n                }\n                hasFollowingResponse = true;\n                if (experimental_onFunctionCall) {\n                    const functionCall = message.function_call;\n                    if (typeof functionCall !== \"object\") {\n                        console.warn(\"experimental_onFunctionCall should not be defined when using tools\");\n                        continue;\n                    }\n                    const functionCallResponse = await experimental_onFunctionCall(getCurrentMessages(), functionCall);\n                    if (functionCallResponse === void 0) {\n                        hasFollowingResponse = false;\n                        break;\n                    }\n                    updateChatRequest(functionCallResponse);\n                }\n                if (experimental_onToolCall) {\n                    const toolCalls = message.tool_calls;\n                    if (!Array.isArray(toolCalls) || toolCalls.some((toolCall)=>typeof toolCall !== \"object\")) {\n                        console.warn(\"experimental_onToolCall should not be defined when using tools\");\n                        continue;\n                    }\n                    const toolCallResponse = await experimental_onToolCall(getCurrentMessages(), toolCalls);\n                    if (toolCallResponse === void 0) {\n                        hasFollowingResponse = false;\n                        break;\n                    }\n                    updateChatRequest(toolCallResponse);\n                }\n            }\n            if (!hasFollowingResponse) {\n                break;\n            }\n        } else {\n            let fixFunctionCallArguments2 = function(response) {\n                for (const message of response.messages){\n                    if (message.tool_calls !== void 0) {\n                        for (const toolCall of message.tool_calls){\n                            if (typeof toolCall === \"object\") {\n                                if (toolCall.function.arguments && typeof toolCall.function.arguments !== \"string\") {\n                                    toolCall.function.arguments = JSON.stringify(toolCall.function.arguments);\n                                }\n                            }\n                        }\n                    }\n                    if (message.function_call !== void 0) {\n                        if (typeof message.function_call === \"object\") {\n                            if (message.function_call.arguments && typeof message.function_call.arguments !== \"string\") {\n                                message.function_call.arguments = JSON.stringify(message.function_call.arguments);\n                            }\n                        }\n                    }\n                }\n            };\n            var fixFunctionCallArguments = fixFunctionCallArguments2;\n            const streamedResponseMessage = messagesAndDataOrJustMessage;\n            if ((streamedResponseMessage.function_call === void 0 || typeof streamedResponseMessage.function_call === \"string\") && (streamedResponseMessage.tool_calls === void 0 || typeof streamedResponseMessage.tool_calls === \"string\")) {\n                break;\n            }\n            if (experimental_onFunctionCall) {\n                const functionCall = streamedResponseMessage.function_call;\n                if (!(typeof functionCall === \"object\")) {\n                    console.warn(\"experimental_onFunctionCall should not be defined when using tools\");\n                    continue;\n                }\n                const functionCallResponse = await experimental_onFunctionCall(getCurrentMessages(), functionCall);\n                if (functionCallResponse === void 0) break;\n                fixFunctionCallArguments2(functionCallResponse);\n                updateChatRequest(functionCallResponse);\n            }\n            if (experimental_onToolCall) {\n                const toolCalls = streamedResponseMessage.tool_calls;\n                if (!(typeof toolCalls === \"object\")) {\n                    console.warn(\"experimental_onToolCall should not be defined when using functions\");\n                    continue;\n                }\n                const toolCallResponse = await experimental_onToolCall(getCurrentMessages(), toolCalls);\n                if (toolCallResponse === void 0) break;\n                fixFunctionCallArguments2(toolCallResponse);\n                updateChatRequest(toolCallResponse);\n            }\n        }\n    }\n}\n// react/use-chat.ts\nvar getStreamedResponse = async (api, chatRequest, mutate, mutateStreamData, existingData, extraMetadataRef, messagesRef, abortControllerRef, generateId2, streamMode, onFinish, onResponse, sendExtraMessageFields)=>{\n    var _a, _b;\n    const previousMessages = messagesRef.current;\n    mutate(chatRequest.messages, false);\n    const constructedMessagesPayload = sendExtraMessageFields ? chatRequest.messages : chatRequest.messages.map(({ role, content, name, toolInvocations, function_call, tool_calls, tool_call_id })=>({\n            role,\n            content,\n            ...name !== void 0 && {\n                name\n            },\n            ...toolInvocations !== void 0 && {\n                toolInvocations\n            },\n            // outdated function/tool call handling (TODO deprecate):\n            tool_call_id,\n            ...function_call !== void 0 && {\n                function_call\n            },\n            ...tool_calls !== void 0 && {\n                tool_calls\n            }\n        }));\n    if (typeof api !== \"string\") {\n        const replyId = generateId2();\n        const createdAt = /* @__PURE__ */ new Date();\n        let responseMessage = {\n            id: replyId,\n            createdAt,\n            content: \"\",\n            role: \"assistant\"\n        };\n        async function readRow(promise) {\n            const { content, ui, next } = await promise;\n            responseMessage[\"content\"] = content;\n            responseMessage[\"ui\"] = await ui;\n            mutate([\n                ...chatRequest.messages,\n                {\n                    ...responseMessage\n                }\n            ], false);\n            if (next) {\n                await readRow(next);\n            }\n        }\n        try {\n            const promise = api({\n                messages: constructedMessagesPayload,\n                data: chatRequest.data\n            });\n            await readRow(promise);\n        } catch (e) {\n            mutate(previousMessages, false);\n            throw e;\n        }\n        if (onFinish) {\n            onFinish(responseMessage);\n        }\n        return responseMessage;\n    }\n    return await callChatApi({\n        api,\n        messages: constructedMessagesPayload,\n        body: {\n            data: chatRequest.data,\n            ...extraMetadataRef.current.body,\n            ...(_a = chatRequest.options) == null ? void 0 : _a.body,\n            ...chatRequest.functions !== void 0 && {\n                functions: chatRequest.functions\n            },\n            ...chatRequest.function_call !== void 0 && {\n                function_call: chatRequest.function_call\n            },\n            ...chatRequest.tools !== void 0 && {\n                tools: chatRequest.tools\n            },\n            ...chatRequest.tool_choice !== void 0 && {\n                tool_choice: chatRequest.tool_choice\n            }\n        },\n        streamMode,\n        credentials: extraMetadataRef.current.credentials,\n        headers: {\n            ...extraMetadataRef.current.headers,\n            ...(_b = chatRequest.options) == null ? void 0 : _b.headers\n        },\n        abortController: ()=>abortControllerRef.current,\n        restoreMessagesOnFailure () {\n            mutate(previousMessages, false);\n        },\n        onResponse,\n        onUpdate (merged, data) {\n            mutate([\n                ...chatRequest.messages,\n                ...merged\n            ], false);\n            mutateStreamData([\n                ...existingData || [],\n                ...data || []\n            ], false);\n        },\n        onFinish,\n        generateId: generateId2\n    });\n};\nfunction useChat({ api = \"/api/chat\", id, initialMessages, initialInput = \"\", sendExtraMessageFields, experimental_onFunctionCall, experimental_onToolCall, experimental_maxAutomaticRoundtrips = 0, streamMode, onResponse, onFinish, onError, credentials, headers, body, generateId: generateId2 = generateId } = {}) {\n    const hookId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n    const idKey = id != null ? id : hookId;\n    const chatKey = typeof api === \"string\" ? [\n        api,\n        idKey\n    ] : idKey;\n    const [initialMessagesFallback] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const { data: messages, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"messages\"\n    ], null, {\n        fallbackData: initialMessages != null ? initialMessages : initialMessagesFallback\n    });\n    const { data: isLoading = false, mutate: mutateLoading } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"loading\"\n    ], null);\n    const { data: streamData, mutate: mutateStreamData } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"streamData\"\n    ], null);\n    const { data: error = void 0, mutate: setError } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"error\"\n    ], null);\n    const messagesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(messages || []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        messagesRef.current = messages || [];\n    }, [\n        messages\n    ]);\n    const abortControllerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const extraMetadataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        credentials,\n        headers,\n        body\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        extraMetadataRef.current = {\n            credentials,\n            headers,\n            body\n        };\n    }, [\n        credentials,\n        headers,\n        body\n    ]);\n    const triggerRequest = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (chatRequest)=>{\n        try {\n            mutateLoading(true);\n            setError(void 0);\n            const abortController = new AbortController();\n            abortControllerRef.current = abortController;\n            await processChatStream({\n                getStreamedResponse: ()=>getStreamedResponse(api, chatRequest, mutate, mutateStreamData, streamData, extraMetadataRef, messagesRef, abortControllerRef, generateId2, streamMode, onFinish, onResponse, sendExtraMessageFields),\n                experimental_onFunctionCall,\n                experimental_onToolCall,\n                updateChatRequest: (chatRequestParam)=>{\n                    chatRequest = chatRequestParam;\n                },\n                getCurrentMessages: ()=>messagesRef.current\n            });\n            abortControllerRef.current = null;\n        } catch (err) {\n            if (err.name === \"AbortError\") {\n                abortControllerRef.current = null;\n                return null;\n            }\n            if (onError && err instanceof Error) {\n                onError(err);\n            }\n            setError(err);\n        } finally{\n            mutateLoading(false);\n        }\n        const messages2 = messagesRef.current;\n        const lastMessage = messages2[messages2.length - 1];\n        if (// ensure there is a last message:\n        lastMessage != null && // check if the feature is enabled:\n        experimental_maxAutomaticRoundtrips > 0 && // check that roundtrip is possible:\n        isAssistantMessageWithCompletedToolCalls(lastMessage) && // limit the number of automatic roundtrips:\n        countTrailingAssistantMessages(messages2) <= experimental_maxAutomaticRoundtrips) {\n            await triggerRequest({\n                messages: messages2\n            });\n        }\n    }, [\n        mutate,\n        mutateLoading,\n        api,\n        extraMetadataRef,\n        onResponse,\n        onFinish,\n        onError,\n        setError,\n        mutateStreamData,\n        streamData,\n        streamMode,\n        sendExtraMessageFields,\n        experimental_onFunctionCall,\n        experimental_onToolCall,\n        experimental_maxAutomaticRoundtrips,\n        messagesRef,\n        abortControllerRef,\n        generateId2\n    ]);\n    const append = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (message, { options, functions, function_call, tools, tool_choice, data } = {})=>{\n        if (!message.id) {\n            message.id = generateId2();\n        }\n        const chatRequest = {\n            messages: messagesRef.current.concat(message),\n            options,\n            data,\n            ...functions !== void 0 && {\n                functions\n            },\n            ...function_call !== void 0 && {\n                function_call\n            },\n            ...tools !== void 0 && {\n                tools\n            },\n            ...tool_choice !== void 0 && {\n                tool_choice\n            }\n        };\n        return triggerRequest(chatRequest);\n    }, [\n        triggerRequest,\n        generateId2\n    ]);\n    const reload = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ({ options, functions, function_call, tools, tool_choice } = {})=>{\n        if (messagesRef.current.length === 0) return null;\n        const lastMessage = messagesRef.current[messagesRef.current.length - 1];\n        if (lastMessage.role === \"assistant\") {\n            const chatRequest2 = {\n                messages: messagesRef.current.slice(0, -1),\n                options,\n                ...functions !== void 0 && {\n                    functions\n                },\n                ...function_call !== void 0 && {\n                    function_call\n                },\n                ...tools !== void 0 && {\n                    tools\n                },\n                ...tool_choice !== void 0 && {\n                    tool_choice\n                }\n            };\n            return triggerRequest(chatRequest2);\n        }\n        const chatRequest = {\n            messages: messagesRef.current,\n            options,\n            ...functions !== void 0 && {\n                functions\n            },\n            ...function_call !== void 0 && {\n                function_call\n            },\n            ...tools !== void 0 && {\n                tools\n            },\n            ...tool_choice !== void 0 && {\n                tool_choice\n            }\n        };\n        return triggerRequest(chatRequest);\n    }, [\n        triggerRequest\n    ]);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (abortControllerRef.current) {\n            abortControllerRef.current.abort();\n            abortControllerRef.current = null;\n        }\n    }, []);\n    const setMessages = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((messages2)=>{\n        mutate(messages2, false);\n        messagesRef.current = messages2;\n    }, [\n        mutate\n    ]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialInput);\n    const handleSubmit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e, options = {}, metadata)=>{\n        if (metadata) {\n            extraMetadataRef.current = {\n                ...extraMetadataRef.current,\n                ...metadata\n            };\n        }\n        e.preventDefault();\n        if (!input) return;\n        append({\n            content: input,\n            role: \"user\",\n            createdAt: /* @__PURE__ */ new Date()\n        }, options);\n        setInput(\"\");\n    }, [\n        input,\n        append\n    ]);\n    const handleInputChange = (e)=>{\n        setInput(e.target.value);\n    };\n    return {\n        messages: messages || [],\n        error,\n        append,\n        reload,\n        stop,\n        setMessages,\n        input,\n        setInput,\n        handleInputChange,\n        handleSubmit,\n        isLoading,\n        data: streamData,\n        experimental_addToolResult: ({ toolCallId, result })=>{\n            const updatedMessages = messagesRef.current.map((message, index, arr)=>// update the tool calls in the last assistant message:\n                index === arr.length - 1 && message.role === \"assistant\" && message.toolInvocations ? {\n                    ...message,\n                    toolInvocations: message.toolInvocations.map((toolInvocation)=>toolInvocation.toolCallId === toolCallId ? {\n                            ...toolInvocation,\n                            result\n                        } : toolInvocation)\n                } : message);\n            mutate(updatedMessages, false);\n            const lastMessage = updatedMessages[updatedMessages.length - 1];\n            if (isAssistantMessageWithCompletedToolCalls(lastMessage)) {\n                triggerRequest({\n                    messages: updatedMessages\n                });\n            }\n        }\n    };\n}\nfunction isAssistantMessageWithCompletedToolCalls(message) {\n    return message.role === \"assistant\" && message.toolInvocations && message.toolInvocations.length > 0 && message.toolInvocations.every((toolInvocation)=>\"result\" in toolInvocation);\n}\nfunction countTrailingAssistantMessages(messages) {\n    let count = 0;\n    for(let i = messages.length - 1; i >= 0; i--){\n        if (messages[i].role === \"assistant\") {\n            count++;\n        } else {\n            break;\n        }\n    }\n    return count;\n}\n// react/use-completion.ts\n\n\n// shared/call-completion-api.ts\nasync function callCompletionApi({ api, prompt, credentials, headers, body, streamMode = \"stream-data\", setCompletion, setLoading, setError, setAbortController, onResponse, onFinish, onError, onData }) {\n    try {\n        setLoading(true);\n        setError(void 0);\n        const abortController = new AbortController();\n        setAbortController(abortController);\n        setCompletion(\"\");\n        const res = await fetch(api, {\n            method: \"POST\",\n            body: JSON.stringify({\n                prompt,\n                ...body\n            }),\n            credentials,\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...headers\n            },\n            signal: abortController.signal\n        }).catch((err)=>{\n            throw err;\n        });\n        if (onResponse) {\n            try {\n                await onResponse(res);\n            } catch (err) {\n                throw err;\n            }\n        }\n        if (!res.ok) {\n            throw new Error(await res.text() || \"Failed to fetch the chat response.\");\n        }\n        if (!res.body) {\n            throw new Error(\"The response body is empty.\");\n        }\n        let result = \"\";\n        const reader = res.body.getReader();\n        switch(streamMode){\n            case \"text\":\n                {\n                    const decoder = createChunkDecoder();\n                    while(true){\n                        const { done, value } = await reader.read();\n                        if (done) {\n                            break;\n                        }\n                        result += decoder(value);\n                        setCompletion(result);\n                        if (abortController === null) {\n                            reader.cancel();\n                            break;\n                        }\n                    }\n                    break;\n                }\n            case \"stream-data\":\n                {\n                    for await (const { type, value } of readDataStream(reader, {\n                        isAborted: ()=>abortController === null\n                    })){\n                        switch(type){\n                            case \"text\":\n                                {\n                                    result += value;\n                                    setCompletion(result);\n                                    break;\n                                }\n                            case \"data\":\n                                {\n                                    onData == null ? void 0 : onData(value);\n                                    break;\n                                }\n                        }\n                    }\n                    break;\n                }\n            default:\n                {\n                    const exhaustiveCheck = streamMode;\n                    throw new Error(`Unknown stream mode: ${exhaustiveCheck}`);\n                }\n        }\n        if (onFinish) {\n            onFinish(prompt, result);\n        }\n        setAbortController(null);\n        return result;\n    } catch (err) {\n        if (err.name === \"AbortError\") {\n            setAbortController(null);\n            return null;\n        }\n        if (err instanceof Error) {\n            if (onError) {\n                onError(err);\n            }\n        }\n        setError(err);\n    } finally{\n        setLoading(false);\n    }\n}\n// react/use-completion.ts\nfunction useCompletion({ api = \"/api/completion\", id, initialCompletion = \"\", initialInput = \"\", credentials, headers, body, streamMode, onResponse, onFinish, onError } = {}) {\n    const hookId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n    const completionId = id || hookId;\n    const { data, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        api,\n        completionId\n    ], null, {\n        fallbackData: initialCompletion\n    });\n    const { data: isLoading = false, mutate: mutateLoading } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        completionId,\n        \"loading\"\n    ], null);\n    const { data: streamData, mutate: mutateStreamData } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        completionId,\n        \"streamData\"\n    ], null);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const completion = data;\n    const [abortController, setAbortController] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const extraMetadataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        credentials,\n        headers,\n        body\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        extraMetadataRef.current = {\n            credentials,\n            headers,\n            body\n        };\n    }, [\n        credentials,\n        headers,\n        body\n    ]);\n    const triggerRequest = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (prompt, options)=>callCompletionApi({\n            api,\n            prompt,\n            credentials: extraMetadataRef.current.credentials,\n            headers: {\n                ...extraMetadataRef.current.headers,\n                ...options == null ? void 0 : options.headers\n            },\n            body: {\n                ...extraMetadataRef.current.body,\n                ...options == null ? void 0 : options.body\n            },\n            streamMode,\n            setCompletion: (completion2)=>mutate(completion2, false),\n            setLoading: mutateLoading,\n            setError,\n            setAbortController,\n            onResponse,\n            onFinish,\n            onError,\n            onData: (data2)=>{\n                mutateStreamData([\n                    ...streamData || [],\n                    ...data2 || []\n                ], false);\n            }\n        }), [\n        mutate,\n        mutateLoading,\n        api,\n        extraMetadataRef,\n        setAbortController,\n        onResponse,\n        onFinish,\n        onError,\n        setError,\n        streamData,\n        streamMode,\n        mutateStreamData\n    ]);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (abortController) {\n            abortController.abort();\n            setAbortController(null);\n        }\n    }, [\n        abortController\n    ]);\n    const setCompletion = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((completion2)=>{\n        mutate(completion2, false);\n    }, [\n        mutate\n    ]);\n    const complete = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (prompt, options)=>{\n        return triggerRequest(prompt, options);\n    }, [\n        triggerRequest\n    ]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialInput);\n    const handleSubmit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        e.preventDefault();\n        if (!input) return;\n        return complete(input);\n    }, [\n        input,\n        complete\n    ]);\n    const handleInputChange = (e)=>{\n        setInput(e.target.value);\n    };\n    return {\n        completion,\n        complete,\n        error,\n        setCompletion,\n        stop,\n        input,\n        setInput,\n        handleInputChange,\n        handleSubmit,\n        isLoading,\n        data: streamData\n    };\n}\n// react/use-assistant.ts\n\n\nfunction useAssistant({ api, threadId: threadIdParam, credentials, headers, body, onError }) {\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [threadId, setThreadId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"awaiting_message\");\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const handleInputChange = (event)=>{\n        setInput(event.target.value);\n    };\n    const abortControllerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (abortControllerRef.current) {\n            abortControllerRef.current.abort();\n            abortControllerRef.current = null;\n        }\n    }, []);\n    const append = async (message, requestOptions)=>{\n        var _a;\n        setStatus(\"in_progress\");\n        setMessages((messages2)=>{\n            var _a2;\n            return [\n                ...messages2,\n                {\n                    ...message,\n                    id: (_a2 = message.id) != null ? _a2 : generateId()\n                }\n            ];\n        });\n        setInput(\"\");\n        const abortController = new AbortController();\n        try {\n            abortControllerRef.current = abortController;\n            const result = await fetch(api, {\n                method: \"POST\",\n                credentials,\n                signal: abortController.signal,\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...headers\n                },\n                body: JSON.stringify({\n                    ...body,\n                    // always use user-provided threadId when available:\n                    threadId: (_a = threadIdParam != null ? threadIdParam : threadId) != null ? _a : null,\n                    message: message.content,\n                    // optional request data:\n                    data: requestOptions == null ? void 0 : requestOptions.data\n                })\n            });\n            if (result.body == null) {\n                throw new Error(\"The response body is empty.\");\n            }\n            for await (const { type, value } of readDataStream(result.body.getReader())){\n                switch(type){\n                    case \"assistant_message\":\n                        {\n                            setMessages((messages2)=>[\n                                    ...messages2,\n                                    {\n                                        id: value.id,\n                                        role: value.role,\n                                        content: value.content[0].text.value\n                                    }\n                                ]);\n                            break;\n                        }\n                    case \"text\":\n                        {\n                            setMessages((messages2)=>{\n                                const lastMessage = messages2[messages2.length - 1];\n                                return [\n                                    ...messages2.slice(0, messages2.length - 1),\n                                    {\n                                        id: lastMessage.id,\n                                        role: lastMessage.role,\n                                        content: lastMessage.content + value\n                                    }\n                                ];\n                            });\n                            break;\n                        }\n                    case \"data_message\":\n                        {\n                            setMessages((messages2)=>{\n                                var _a2;\n                                return [\n                                    ...messages2,\n                                    {\n                                        id: (_a2 = value.id) != null ? _a2 : generateId(),\n                                        role: \"data\",\n                                        content: \"\",\n                                        data: value.data\n                                    }\n                                ];\n                            });\n                            break;\n                        }\n                    case \"assistant_control_data\":\n                        {\n                            setThreadId(value.threadId);\n                            setMessages((messages2)=>{\n                                const lastMessage = messages2[messages2.length - 1];\n                                lastMessage.id = value.messageId;\n                                return [\n                                    ...messages2.slice(0, messages2.length - 1),\n                                    lastMessage\n                                ];\n                            });\n                            break;\n                        }\n                    case \"error\":\n                        {\n                            setError(new Error(value));\n                            break;\n                        }\n                }\n            }\n        } catch (error2) {\n            if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_3__.isAbortError)(error2) && abortController.signal.aborted) {\n                abortControllerRef.current = null;\n                return;\n            }\n            if (onError && error2 instanceof Error) {\n                onError(error2);\n            }\n            setError(error2);\n        } finally{\n            abortControllerRef.current = null;\n            setStatus(\"awaiting_message\");\n        }\n    };\n    const submitMessage = async (event, requestOptions)=>{\n        var _a;\n        (_a = event == null ? void 0 : event.preventDefault) == null ? void 0 : _a.call(event);\n        if (input === \"\") {\n            return;\n        }\n        append({\n            role: \"user\",\n            content: input\n        }, requestOptions);\n    };\n    return {\n        append,\n        messages,\n        setMessages,\n        threadId,\n        input,\n        setInput,\n        handleInputChange,\n        submitMessage,\n        status,\n        error,\n        stop\n    };\n}\nvar experimental_useAssistant = useAssistant;\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWkvcmVhY3QvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQWdFO0FBQzNCOztBQ0ROO0FBS3hCLElBQU1PLGFBQWFELGlFQUFjQSxDQUN0QyxrRUFDQTs7QUNVRixJQUFNRSxpQkFBa0Q7SUFDdERDLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxPQUFPLENBQUNDO1FBQ04sSUFBSSxPQUFPQSxVQUFVLFVBQVU7WUFDN0IsTUFBTSxJQUFJQyxNQUFNO1FBQ2xCO1FBQ0EsT0FBTztZQUFFQyxNQUFNO1lBQVFGO1FBQU07SUFDL0I7QUFDRjtBQUVBLElBQU1HLHlCQUlGO0lBQ0ZOLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxPQUFPLENBQUNDO1FBQ04sSUFDRUEsU0FBUyxRQUNULE9BQU9BLFVBQVUsWUFDakIsQ0FBRSxvQkFBbUJBLEtBQUEsS0FDckIsT0FBT0EsTUFBTUksYUFBQSxLQUFrQixZQUMvQkosTUFBTUksYUFBQSxJQUFpQixRQUN2QixDQUFFLFdBQVVKLE1BQU1JLGFBQUEsS0FDbEIsQ0FBRSxnQkFBZUosTUFBTUksYUFBQSxLQUN2QixPQUFPSixNQUFNSSxhQUFBLENBQWNOLElBQUEsS0FBUyxZQUNwQyxPQUFPRSxNQUFNSSxhQUFBLENBQWNDLFNBQUEsS0FBYyxVQUN6QztZQUNBLE1BQU0sSUFBSUosTUFDUjtRQUVKO1FBRUEsT0FBTztZQUNMQyxNQUFNO1lBQ05GO1FBQ0Y7SUFDRjtBQUNGO0FBRUEsSUFBTU0saUJBQTREO0lBQ2hFVCxNQUFNO0lBQ05DLE1BQU07SUFDTkMsT0FBTyxDQUFDQztRQUNOLElBQUksQ0FBQ08sTUFBTUMsT0FBQSxDQUFRUixRQUFRO1lBQ3pCLE1BQU0sSUFBSUMsTUFBTTtRQUNsQjtRQUVBLE9BQU87WUFBRUMsTUFBTTtZQUFRRjtRQUFNO0lBQy9CO0FBQ0Y7QUFFQSxJQUFNUyxrQkFBb0Q7SUFDeERaLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxPQUFPLENBQUND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NEJBQ2hFOzRCQUVBO3dCQUNGO29CQUVBLEtBQUs7d0JBQVM7NEJBQ1pKLFNBQVMsSUFBSWhMLE1BQU1EOzRCQUNuQjt3QkFDRjtnQkFDRjtZQUNGO1FBQ0YsU0FBU2dMLFFBQU87WUFFZCxJQUFJeUMsb0VBQVlBLENBQUN6QyxXQUFVcEUsZ0JBQWdCUyxNQUFBLENBQU80RyxPQUFBLEVBQVM7Z0JBQ3pEckosbUJBQW1CUyxPQUFBLEdBQVU7Z0JBQzdCO1lBQ0Y7WUFFQSxJQUFJa0YsV0FBV1Msa0JBQWlCL0ssT0FBTztnQkFDckNzSyxRQUFRUztZQUNWO1lBRUFDLFNBQVNEO1FBQ1gsU0FBRTtZQUNBcEcsbUJBQW1CUyxPQUFBLEdBQVU7WUFDN0J5SSxVQUFVO1FBQ1o7SUFDRjtJQUVBLE1BQU1JLGdCQUFnQixPQUNwQkgsT0FDQUM7UUF2UEosSUFBQWhIO1FBMlBJQSxDQUFBQSxLQUFBK0csU0FBQSxnQkFBQUEsTUFBTzdCLGNBQUEsS0FBUCxnQkFBQWxGLEdBQUFtSCxJQUFBLENBQUFKO1FBRUEsSUFBSWpDLFVBQVUsSUFBSTtZQUNoQjtRQUNGO1FBRUFOLE9BQU87WUFBRTVLLE1BQU07WUFBUUMsU0FBU2lMO1FBQU0sR0FBR2tDO0lBQzNDO0lBRUEsT0FBTztRQUNMeEM7UUFDQXRGO1FBQ0EyRjtRQUNBM0s7UUFDQTRLO1FBQ0FDO1FBQ0FJO1FBQ0ErQjtRQUNBTDtRQUNBN0M7UUFDQVc7SUFDRjtBQUNGO0FBS08sSUFBTXlDLDRCQUE0QlYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydHgvLi4vdXNlLWNoYXQudHM/ODgyOCIsIndlYnBhY2s6Ly9zbWFydHgvLi4vLi4vc2hhcmVkL2dlbmVyYXRlLWlkLnRzPzBkNWYiLCJ3ZWJwYWNrOi8vc21hcnR4Ly4uLy4uL3NoYXJlZC9zdHJlYW0tcGFydHMudHM/YzRhOCIsIndlYnBhY2s6Ly9zbWFydHgvLi4vLi4vc2hhcmVkL3JlYWQtZGF0YS1zdHJlYW0udHM/MThmMSIsIndlYnBhY2s6Ly9zbWFydHgvLi4vLi4vc2hhcmVkL3BhcnNlLWNvbXBsZXgtcmVzcG9uc2UudHM/NjVlMCIsIndlYnBhY2s6Ly9zbWFydHgvLi4vLi4vc2hhcmVkL3V0aWxzLnRzP2Y4Y2YiLCJ3ZWJwYWNrOi8vc21hcnR4Ly4uLy4uL3NoYXJlZC9jYWxsLWNoYXQtYXBpLnRzP2I1NWIiLCJ3ZWJwYWNrOi8vc21hcnR4Ly4uLy4uL3NoYXJlZC9wcm9jZXNzLWNoYXQtc3RyZWFtLnRzPzhkN2YiLCJ3ZWJwYWNrOi8vc21hcnR4Ly4uL3VzZS1jb21wbGV0aW9uLnRzP2FlN2YiLCJ3ZWJwYWNrOi8vc21hcnR4Ly4uLy4uL3NoYXJlZC9jYWxsLWNvbXBsZXRpb24tYXBpLnRzPzg1MjUiLCJ3ZWJwYWNrOi8vc21hcnR4Ly4uL3VzZS1hc3Npc3RhbnQudHM/MjgxMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VJZCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VTV1IsIHsgS2V5ZWRNdXRhdG9yIH0gZnJvbSAnc3dyJztcbmltcG9ydCB7IGNhbGxDaGF0QXBpIH0gZnJvbSAnLi4vc2hhcmVkL2NhbGwtY2hhdC1hcGknO1xuaW1wb3J0IHsgZ2VuZXJhdGVJZCBhcyBnZW5lcmF0ZUlkRnVuYyB9IGZyb20gJy4uL3NoYXJlZC9nZW5lcmF0ZS1pZCc7XG5pbXBvcnQgeyBwcm9jZXNzQ2hhdFN0cmVhbSB9IGZyb20gJy4uL3NoYXJlZC9wcm9jZXNzLWNoYXQtc3RyZWFtJztcbmltcG9ydCB0eXBlIHtcbiAgQ2hhdFJlcXVlc3QsXG4gIENoYXRSZXF1ZXN0T3B0aW9ucyxcbiAgQ3JlYXRlTWVzc2FnZSxcbiAgSWRHZW5lcmF0b3IsXG4gIEpTT05WYWx1ZSxcbiAgTWVzc2FnZSxcbiAgVXNlQ2hhdE9wdGlvbnMsXG59IGZyb20gJy4uL3NoYXJlZC90eXBlcyc7XG5pbXBvcnQgdHlwZSB7XG4gIFJlYWN0UmVzcG9uc2VSb3csXG4gIGV4cGVyaW1lbnRhbF9TdHJlYW1pbmdSZWFjdFJlc3BvbnNlLFxufSBmcm9tICcuLi9zdHJlYW1zL3N0cmVhbWluZy1yZWFjdC1yZXNwb25zZSc7XG5cbmV4cG9ydCB0eXBlIHsgQ3JlYXRlTWVzc2FnZSwgTWVzc2FnZSwgVXNlQ2hhdE9wdGlvbnMgfTtcblxuZXhwb3J0IHR5cGUgVXNlQ2hhdEhlbHBlcnMgPSB7XG4gIC8qKiBDdXJyZW50IG1lc3NhZ2VzIGluIHRoZSBjaGF0ICovXG4gIG1lc3NhZ2VzOiBNZXNzYWdlW107XG4gIC8qKiBUaGUgZXJyb3Igb2JqZWN0IG9mIHRoZSBBUEkgcmVxdWVzdCAqL1xuICBlcnJvcjogdW5kZWZpbmVkIHwgRXJyb3I7XG4gIC8qKlxuICAgKiBBcHBlbmQgYSB1c2VyIG1lc3NhZ2UgdG8gdGhlIGNoYXQgbGlzdC4gVGhpcyB0cmlnZ2VycyB0aGUgQVBJIGNhbGwgdG8gZmV0Y2hcbiAgICogdGhlIGFzc2lzdGFudCdzIHJlc3BvbnNlLlxuICAgKiBAcGFyYW0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBhcHBlbmRcbiAgICogQHBhcmFtIG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIEFQSSBjYWxsXG4gICAqL1xuICBhcHBlbmQ6IChcbiAgICBtZXNzYWdlOiBNZXNzYWdlIHwgQ3JlYXRlTWVzc2FnZSxcbiAgICBjaGF0UmVxdWVzdE9wdGlvbnM/OiBDaGF0UmVxdWVzdE9wdGlvbnMsXG4gICkgPT4gUHJvbWlzZTxzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkPjtcbiAgLyoqXG4gICAqIFJlbG9hZCB0aGUgbGFzdCBBSSBjaGF0IHJlc3BvbnNlIGZvciB0aGUgZ2l2ZW4gY2hhdCBoaXN0b3J5LiBJZiB0aGUgbGFzdFxuICAgKiBtZXNzYWdlIGlzbid0IGZyb20gdGhlIGFzc2lzdGFudCwgaXQgd2lsbCByZXF1ZXN0IHRoZSBBUEkgdG8gZ2VuZXJhdGUgYVxuICAgKiBuZXcgcmVzcG9uc2UuXG4gICAqL1xuICByZWxvYWQ6IChcbiAgICBjaGF0UmVxdWVzdE9wdGlvbnM/OiBDaGF0UmVxdWVzdE9wdGlvbnMsXG4gICkgPT4gUHJvbWlzZTxzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkPjtcbiAgLyoqXG4gICAqIEFib3J0IHRoZSBjdXJyZW50IHJlcXVlc3QgaW1tZWRpYXRlbHksIGtlZXAgdGhlIGdlbmVyYXRlZCB0b2tlbnMgaWYgYW55LlxuICAgKi9cbiAgc3RvcDogKCkgPT4gdm9pZDtcbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgYG1lc3NhZ2VzYCBzdGF0ZSBsb2NhbGx5LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHlvdSB3YW50IHRvXG4gICAqIGVkaXQgdGhlIG1lc3NhZ2VzIG9uIHRoZSBjbGllbnQsIGFuZCB0aGVuIHRyaWdnZXIgdGhlIGByZWxvYWRgIG1ldGhvZFxuICAgKiBtYW51YWxseSB0byByZWdlbmVyYXRlIHRoZSBBSSByZXNwb25zZS5cbiAgICovXG4gIHNldE1lc3NhZ2VzOiAobWVzc2FnZXM6IE1lc3NhZ2VbXSkgPT4gdm9pZDtcbiAgLyoqIFRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBpbnB1dCAqL1xuICBpbnB1dDogc3RyaW5nO1xuICAvKiogc2V0U3RhdGUtcG93ZXJlZCBtZXRob2QgdG8gdXBkYXRlIHRoZSBpbnB1dCB2YWx1ZSAqL1xuICBzZXRJbnB1dDogUmVhY3QuRGlzcGF0Y2g8UmVhY3QuU2V0U3RhdGVBY3Rpb248c3RyaW5nPj47XG4gIC8qKiBBbiBpbnB1dC90ZXh0YXJlYS1yZWFkeSBvbkNoYW5nZSBoYW5kbGVyIHRvIGNvbnRyb2wgdGhlIHZhbHVlIG9mIHRoZSBpbnB1dCAqL1xuICBoYW5kbGVJbnB1dENoYW5nZTogKFxuICAgIGU6XG4gICAgICB8IFJlYWN0LkNoYW5nZUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+XG4gICAgICB8IFJlYWN0LkNoYW5nZUV2ZW50PEhUTUxUZXh0QXJlYUVsZW1lbnQ+LFxuICApID0+IHZvaWQ7XG4gIC8qKiBGb3JtIHN1Ym1pc3Npb24gaGFuZGxlciB0byBhdXRvbWF0aWNhbGx5IHJlc2V0IGlucHV0IGFuZCBhcHBlbmQgYSB1c2VyIG1lc3NhZ2UgKi9cbiAgaGFuZGxlU3VibWl0OiAoXG4gICAgZTogUmVhY3QuRm9ybUV2ZW50PEhUTUxGb3JtRWxlbWVudD4sXG4gICAgY2hhdFJlcXVlc3RPcHRpb25zPzogQ2hhdFJlcXVlc3RPcHRpb25zLFxuICApID0+IHZvaWQ7XG4gIG1ldGFkYXRhPzogT2JqZWN0O1xuICAvKiogV2hldGhlciB0aGUgQVBJIHJlcXVlc3QgaXMgaW4gcHJvZ3Jlc3MgKi9cbiAgaXNMb2FkaW5nOiBib29sZWFuO1xuICAvKiogQWRkaXRpb25hbCBkYXRhIGFkZGVkIG9uIHRoZSBzZXJ2ZXIgdmlhIFN0cmVhbURhdGEgKi9cbiAgZGF0YT86IEpTT05WYWx1ZVtdO1xufTtcblxuLyoqXG5AZGVwcmVjYXRlZCBVc2UgQUkgU0RLIFJTQyBpbnN0ZWFkOiBodHRwczovL3Nkay52ZXJjZWwuYWkvZG9jcy9haS1zZGstcnNjXG4gKi9cbnR5cGUgU3RyZWFtaW5nUmVhY3RSZXNwb25zZUFjdGlvbiA9IChwYXlsb2FkOiB7XG4gIG1lc3NhZ2VzOiBNZXNzYWdlW107XG4gIGRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xufSkgPT4gUHJvbWlzZTxleHBlcmltZW50YWxfU3RyZWFtaW5nUmVhY3RSZXNwb25zZT47XG5cbmNvbnN0IGdldFN0cmVhbWVkUmVzcG9uc2UgPSBhc3luYyAoXG4gIGFwaTogc3RyaW5nIHwgU3RyZWFtaW5nUmVhY3RSZXNwb25zZUFjdGlvbixcbiAgY2hhdFJlcXVlc3Q6IENoYXRSZXF1ZXN0LFxuICBtdXRhdGU6IEtleWVkTXV0YXRvcjxNZXNzYWdlW10+LFxuICBtdXRhdGVTdHJlYW1EYXRhOiBLZXllZE11dGF0b3I8SlNPTlZhbHVlW10gfCB1bmRlZmluZWQ+LFxuICBleGlzdGluZ0RhdGE6IEpTT05WYWx1ZVtdIHwgdW5kZWZpbmVkLFxuICBleHRyYU1ldGFkYXRhUmVmOiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PGFueT4sXG4gIG1lc3NhZ2VzUmVmOiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PE1lc3NhZ2VbXT4sXG4gIGFib3J0Q29udHJvbGxlclJlZjogUmVhY3QuTXV0YWJsZVJlZk9iamVjdDxBYm9ydENvbnRyb2xsZXIgfCBudWxsPixcbiAgZ2VuZXJhdGVJZDogSWRHZW5lcmF0b3IsXG4gIHN0cmVhbU1vZGU/OiAnc3RyZWFtLWRhdGEnIHwgJ3RleHQnLFxuICBvbkZpbmlzaD86IChtZXNzYWdlOiBNZXNzYWdlKSA9PiB2b2lkLFxuICBvblJlc3BvbnNlPzogKHJlc3BvbnNlOiBSZXNwb25zZSkgPT4gdm9pZCB8IFByb21pc2U8dm9pZD4sXG4gIHNlbmRFeHRyYU1lc3NhZ2VGaWVsZHM/OiBib29sZWFuLFxuKSA9PiB7XG4gIC8vIERvIGFuIG9wdGltaXN0aWMgdXBkYXRlIHRvIHRoZSBjaGF0IHN0YXRlIHRvIHNob3cgdGhlIHVwZGF0ZWQgbWVzc2FnZXNcbiAgLy8gaW1tZWRpYXRlbHkuXG4gIGNvbnN0IHByZXZpb3VzTWVzc2FnZXMgPSBtZXNzYWdlc1JlZi5jdXJyZW50O1xuICBtdXRhdGUoY2hhdFJlcXVlc3QubWVzc2FnZXMsIGZhbHNlKTtcblxuICBjb25zdCBjb25zdHJ1Y3RlZE1lc3NhZ2VzUGF5bG9hZCA9IHNlbmRFeHRyYU1lc3NhZ2VGaWVsZHNcbiAgICA/IGNoYXRSZXF1ZXN0Lm1lc3NhZ2VzXG4gICAgOiBjaGF0UmVxdWVzdC5tZXNzYWdlcy5tYXAoXG4gICAgICAgICh7XG4gICAgICAgICAgcm9sZSxcbiAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgdG9vbEludm9jYXRpb25zLFxuICAgICAgICAgIGZ1bmN0aW9uX2NhbGwsXG4gICAgICAgICAgdG9vbF9jYWxscyxcbiAgICAgICAgICB0b29sX2NhbGxfaWQsXG4gICAgICAgIH0pID0+ICh7XG4gICAgICAgICAgcm9sZSxcbiAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgIC4uLihuYW1lICE9PSB1bmRlZmluZWQgJiYgeyBuYW1lIH0pLFxuICAgICAgICAgIC4uLih0b29sSW52b2NhdGlvbnMgIT09IHVuZGVmaW5lZCAmJiB7IHRvb2xJbnZvY2F0aW9ucyB9KSxcbiAgICAgICAgICAvLyBvdXRkYXRlZCBmdW5jdGlvbi90b29sIGNhbGwgaGFuZGxpbmcgKFRPRE8gZGVwcmVjYXRlKTpcbiAgICAgICAgICB0b29sX2NhbGxfaWQsXG4gICAgICAgICAgLi4uKGZ1bmN0aW9uX2NhbGwgIT09IHVuZGVmaW5lZCAmJiB7IGZ1bmN0aW9uX2NhbGwgfSksXG4gICAgICAgICAgLi4uKHRvb2xfY2FsbHMgIT09IHVuZGVmaW5lZCAmJiB7IHRvb2xfY2FsbHMgfSksXG4gICAgICAgIH0pLFxuICAgICAgKTtcblxuICAvLyBUT0RPIGRlcHJlY2F0ZWQsIHJlbW92ZSBpbiBuZXh0IG1ham9yIHJlbGVhc2VcbiAgaWYgKHR5cGVvZiBhcGkgIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gSW4gdGhpcyBjYXNlLCB3ZSBhcmUgaGFuZGxpbmcgYSBTZXJ2ZXIgQWN0aW9uLiBObyBjb21wbGV4IG1vZGUgaGFuZGxpbmcgbmVlZGVkLlxuXG4gICAgY29uc3QgcmVwbHlJZCA9IGdlbmVyYXRlSWQoKTtcbiAgICBjb25zdCBjcmVhdGVkQXQgPSBuZXcgRGF0ZSgpO1xuICAgIGxldCByZXNwb25zZU1lc3NhZ2U6IE1lc3NhZ2UgPSB7XG4gICAgICBpZDogcmVwbHlJZCxcbiAgICAgIGNyZWF0ZWRBdCxcbiAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgcm9sZTogJ2Fzc2lzdGFudCcsXG4gICAgfTtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJlYWRSb3cocHJvbWlzZTogUHJvbWlzZTxSZWFjdFJlc3BvbnNlUm93Pikge1xuICAgICAgY29uc3QgeyBjb250ZW50LCB1aSwgbmV4dCB9ID0gYXdhaXQgcHJvbWlzZTtcblxuICAgICAgLy8gVE9ETzogSGFuZGxlIGZ1bmN0aW9uIGNhbGxzLlxuICAgICAgcmVzcG9uc2VNZXNzYWdlWydjb250ZW50J10gPSBjb250ZW50O1xuICAgICAgcmVzcG9uc2VNZXNzYWdlWyd1aSddID0gYXdhaXQgdWk7XG5cbiAgICAgIG11dGF0ZShbLi4uY2hhdFJlcXVlc3QubWVzc2FnZXMsIHsgLi4ucmVzcG9uc2VNZXNzYWdlIH1dLCBmYWxzZSk7XG5cbiAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgIGF3YWl0IHJlYWRSb3cobmV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHByb21pc2UgPSBhcGkoe1xuICAgICAgICBtZXNzYWdlczogY29uc3RydWN0ZWRNZXNzYWdlc1BheWxvYWQgYXMgTWVzc2FnZVtdLFxuICAgICAgICBkYXRhOiBjaGF0UmVxdWVzdC5kYXRhLFxuICAgICAgfSkgYXMgUHJvbWlzZTxSZWFjdFJlc3BvbnNlUm93PjtcbiAgICAgIGF3YWl0IHJlYWRSb3cocHJvbWlzZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gUmVzdG9yZSB0aGUgcHJldmlvdXMgbWVzc2FnZXMgaWYgdGhlIHJlcXVlc3QgZmFpbHMuXG4gICAgICBtdXRhdGUocHJldmlvdXNNZXNzYWdlcywgZmFsc2UpO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICBpZiAob25GaW5pc2gpIHtcbiAgICAgIG9uRmluaXNoKHJlc3BvbnNlTWVzc2FnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlTWVzc2FnZTtcbiAgfVxuXG4gIHJldHVybiBhd2FpdCBjYWxsQ2hhdEFwaSh7XG4gICAgYXBpLFxuICAgIG1lc3NhZ2VzOiBjb25zdHJ1Y3RlZE1lc3NhZ2VzUGF5bG9hZCxcbiAgICBib2R5OiB7XG4gICAgICBkYXRhOiBjaGF0UmVxdWVzdC5kYXRhLFxuICAgICAgLi4uZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LmJvZHksXG4gICAgICAuLi5jaGF0UmVxdWVzdC5vcHRpb25zPy5ib2R5LFxuICAgICAgLi4uKGNoYXRSZXF1ZXN0LmZ1bmN0aW9ucyAhPT0gdW5kZWZpbmVkICYmIHtcbiAgICAgICAgZnVuY3Rpb25zOiBjaGF0UmVxdWVzdC5mdW5jdGlvbnMsXG4gICAgICB9KSxcbiAgICAgIC4uLihjaGF0UmVxdWVzdC5mdW5jdGlvbl9jYWxsICE9PSB1bmRlZmluZWQgJiYge1xuICAgICAgICBmdW5jdGlvbl9jYWxsOiBjaGF0UmVxdWVzdC5mdW5jdGlvbl9jYWxsLFxuICAgICAgfSksXG4gICAgICAuLi4oY2hhdFJlcXVlc3QudG9vbHMgIT09IHVuZGVmaW5lZCAmJiB7XG4gICAgICAgIHRvb2xzOiBjaGF0UmVxdWVzdC50b29scyxcbiAgICAgIH0pLFxuICAgICAgLi4uKGNoYXRSZXF1ZXN0LnRvb2xfY2hvaWNlICE9PSB1bmRlZmluZWQgJiYge1xuICAgICAgICB0b29sX2Nob2ljZTogY2hhdFJlcXVlc3QudG9vbF9jaG9pY2UsXG4gICAgICB9KSxcbiAgICB9LFxuICAgIHN0cmVhbU1vZGUsXG4gICAgY3JlZGVudGlhbHM6IGV4dHJhTWV0YWRhdGFSZWYuY3VycmVudC5jcmVkZW50aWFscyxcbiAgICBoZWFkZXJzOiB7XG4gICAgICAuLi5leHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQuaGVhZGVycyxcbiAgICAgIC4uLmNoYXRSZXF1ZXN0Lm9wdGlvbnM/LmhlYWRlcnMsXG4gICAgfSxcbiAgICBhYm9ydENvbnRyb2xsZXI6ICgpID0+IGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50LFxuICAgIHJlc3RvcmVNZXNzYWdlc09uRmFpbHVyZSgpIHtcbiAgICAgIG11dGF0ZShwcmV2aW91c01lc3NhZ2VzLCBmYWxzZSk7XG4gICAgfSxcbiAgICBvblJlc3BvbnNlLFxuICAgIG9uVXBkYXRlKG1lcmdlZCwgZGF0YSkge1xuICAgICAgbXV0YXRlKFsuLi5jaGF0UmVxdWVzdC5tZXNzYWdlcywgLi4ubWVyZ2VkXSwgZmFsc2UpO1xuICAgICAgbXV0YXRlU3RyZWFtRGF0YShbLi4uKGV4aXN0aW5nRGF0YSB8fCBbXSksIC4uLihkYXRhIHx8IFtdKV0sIGZhbHNlKTtcbiAgICB9LFxuICAgIG9uRmluaXNoLFxuICAgIGdlbmVyYXRlSWQsXG4gIH0pO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoYXQoe1xuICBhcGkgPSAnL2FwaS9jaGF0JyxcbiAgaWQsXG4gIGluaXRpYWxNZXNzYWdlcyxcbiAgaW5pdGlhbElucHV0ID0gJycsXG4gIHNlbmRFeHRyYU1lc3NhZ2VGaWVsZHMsXG4gIGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCxcbiAgZXhwZXJpbWVudGFsX29uVG9vbENhbGwsXG4gIGV4cGVyaW1lbnRhbF9tYXhBdXRvbWF0aWNSb3VuZHRyaXBzID0gMCxcbiAgc3RyZWFtTW9kZSxcbiAgb25SZXNwb25zZSxcbiAgb25GaW5pc2gsXG4gIG9uRXJyb3IsXG4gIGNyZWRlbnRpYWxzLFxuICBoZWFkZXJzLFxuICBib2R5LFxuICBnZW5lcmF0ZUlkID0gZ2VuZXJhdGVJZEZ1bmMsXG59OiBPbWl0PFVzZUNoYXRPcHRpb25zLCAnYXBpJz4gJiB7XG4gIGFwaT86IHN0cmluZyB8IFN0cmVhbWluZ1JlYWN0UmVzcG9uc2VBY3Rpb247XG4gIGtleT86IHN0cmluZztcbiAgLyoqXG5NYXhpbWFsIG51bWJlciBvZiBhdXRvbWF0aWMgcm91bmR0cmlwcyBmb3IgdG9vbCBjYWxscy5cblxuQW4gYXV0b21hdGljIHRvb2wgY2FsbCByb3VuZHRyaXAgaXMgYSBjYWxsIHRvIHRoZSBzZXJ2ZXIgd2l0aCB0aGUgXG50b29sIGNhbGwgcmVzdWx0cyB3aGVuIGFsbCB0b29sIGNhbGxzIGluIHRoZSBsYXN0IGFzc2lzdGFudCBcbm1lc3NhZ2UgaGF2ZSByZXN1bHRzLlxuXG5BIG1heGltdW0gbnVtYmVyIGlzIHJlcXVpcmVkIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHMgaW4gdGhlXG5jYXNlIG9mIG1pc2NvbmZpZ3VyZWQgdG9vbHMuXG5cbkJ5IGRlZmF1bHQsIGl0J3Mgc2V0IHRvIDAsIHdoaWNoIHdpbGwgZGlzYWJsZSB0aGUgZmVhdHVyZS5cbiAgICovXG4gIGV4cGVyaW1lbnRhbF9tYXhBdXRvbWF0aWNSb3VuZHRyaXBzPzogbnVtYmVyO1xufSA9IHt9KTogVXNlQ2hhdEhlbHBlcnMgJiB7XG4gIGV4cGVyaW1lbnRhbF9hZGRUb29sUmVzdWx0OiAoe1xuICAgIHRvb2xDYWxsSWQsXG4gICAgcmVzdWx0LFxuICB9OiB7XG4gICAgdG9vbENhbGxJZDogc3RyaW5nO1xuICAgIHJlc3VsdDogYW55O1xuICB9KSA9PiB2b2lkO1xufSB7XG4gIC8vIEdlbmVyYXRlIGEgdW5pcXVlIGlkIGZvciB0aGUgY2hhdCBpZiBub3QgcHJvdmlkZWQuXG4gIGNvbnN0IGhvb2tJZCA9IHVzZUlkKCk7XG4gIGNvbnN0IGlkS2V5ID0gaWQgPz8gaG9va0lkO1xuICBjb25zdCBjaGF0S2V5ID0gdHlwZW9mIGFwaSA9PT0gJ3N0cmluZycgPyBbYXBpLCBpZEtleV0gOiBpZEtleTtcblxuICAvLyBTdG9yZSBhIGVtcHR5IGFycmF5IGFzIHRoZSBpbml0aWFsIG1lc3NhZ2VzXG4gIC8vIChpbnN0ZWFkIG9mIHVzaW5nIGEgZGVmYXVsdCBwYXJhbWV0ZXIgdmFsdWUgdGhhdCBnZXRzIHJlLWNyZWF0ZWQgZWFjaCB0aW1lKVxuICAvLyB0byBhdm9pZCByZS1yZW5kZXJzOlxuICBjb25zdCBbaW5pdGlhbE1lc3NhZ2VzRmFsbGJhY2tdID0gdXNlU3RhdGUoW10pO1xuXG4gIC8vIFN0b3JlIHRoZSBjaGF0IHN0YXRlIGluIFNXUiwgdXNpbmcgdGhlIGNoYXRJZCBhcyB0aGUga2V5IHRvIHNoYXJlIHN0YXRlcy5cbiAgY29uc3QgeyBkYXRhOiBtZXNzYWdlcywgbXV0YXRlIH0gPSB1c2VTV1I8TWVzc2FnZVtdPihcbiAgICBbY2hhdEtleSwgJ21lc3NhZ2VzJ10sXG4gICAgbnVsbCxcbiAgICB7IGZhbGxiYWNrRGF0YTogaW5pdGlhbE1lc3NhZ2VzID8/IGluaXRpYWxNZXNzYWdlc0ZhbGxiYWNrIH0sXG4gICk7XG5cbiAgLy8gV2Ugc3RvcmUgbG9hZGluZyBzdGF0ZSBpbiBhbm90aGVyIGhvb2sgdG8gc3luYyBsb2FkaW5nIHN0YXRlcyBhY3Jvc3MgaG9vayBpbnZvY2F0aW9uc1xuICBjb25zdCB7IGRhdGE6IGlzTG9hZGluZyA9IGZhbHNlLCBtdXRhdGU6IG11dGF0ZUxvYWRpbmcgfSA9IHVzZVNXUjxib29sZWFuPihcbiAgICBbY2hhdEtleSwgJ2xvYWRpbmcnXSxcbiAgICBudWxsLFxuICApO1xuXG4gIGNvbnN0IHsgZGF0YTogc3RyZWFtRGF0YSwgbXV0YXRlOiBtdXRhdGVTdHJlYW1EYXRhIH0gPSB1c2VTV1I8XG4gICAgSlNPTlZhbHVlW10gfCB1bmRlZmluZWRcbiAgPihbY2hhdEtleSwgJ3N0cmVhbURhdGEnXSwgbnVsbCk7XG5cbiAgY29uc3QgeyBkYXRhOiBlcnJvciA9IHVuZGVmaW5lZCwgbXV0YXRlOiBzZXRFcnJvciB9ID0gdXNlU1dSPFxuICAgIHVuZGVmaW5lZCB8IEVycm9yXG4gID4oW2NoYXRLZXksICdlcnJvciddLCBudWxsKTtcblxuICAvLyBLZWVwIHRoZSBsYXRlc3QgbWVzc2FnZXMgaW4gYSByZWYuXG4gIGNvbnN0IG1lc3NhZ2VzUmVmID0gdXNlUmVmPE1lc3NhZ2VbXT4obWVzc2FnZXMgfHwgW10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIG1lc3NhZ2VzUmVmLmN1cnJlbnQgPSBtZXNzYWdlcyB8fCBbXTtcbiAgfSwgW21lc3NhZ2VzXSk7XG5cbiAgLy8gQWJvcnQgY29udHJvbGxlciB0byBjYW5jZWwgdGhlIGN1cnJlbnQgQVBJIGNhbGwuXG4gIGNvbnN0IGFib3J0Q29udHJvbGxlclJlZiA9IHVzZVJlZjxBYm9ydENvbnRyb2xsZXIgfCBudWxsPihudWxsKTtcblxuICBjb25zdCBleHRyYU1ldGFkYXRhUmVmID0gdXNlUmVmKHtcbiAgICBjcmVkZW50aWFscyxcbiAgICBoZWFkZXJzLFxuICAgIGJvZHksXG4gIH0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50ID0ge1xuICAgICAgY3JlZGVudGlhbHMsXG4gICAgICBoZWFkZXJzLFxuICAgICAgYm9keSxcbiAgICB9O1xuICB9LCBbY3JlZGVudGlhbHMsIGhlYWRlcnMsIGJvZHldKTtcblxuICBjb25zdCB0cmlnZ2VyUmVxdWVzdCA9IHVzZUNhbGxiYWNrKFxuICAgIGFzeW5jIChjaGF0UmVxdWVzdDogQ2hhdFJlcXVlc3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG11dGF0ZUxvYWRpbmcodHJ1ZSk7XG4gICAgICAgIHNldEVycm9yKHVuZGVmaW5lZCk7XG5cbiAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9IGFib3J0Q29udHJvbGxlcjtcblxuICAgICAgICBhd2FpdCBwcm9jZXNzQ2hhdFN0cmVhbSh7XG4gICAgICAgICAgZ2V0U3RyZWFtZWRSZXNwb25zZTogKCkgPT5cbiAgICAgICAgICAgIGdldFN0cmVhbWVkUmVzcG9uc2UoXG4gICAgICAgICAgICAgIGFwaSxcbiAgICAgICAgICAgICAgY2hhdFJlcXVlc3QsXG4gICAgICAgICAgICAgIG11dGF0ZSxcbiAgICAgICAgICAgICAgbXV0YXRlU3RyZWFtRGF0YSxcbiAgICAgICAgICAgICAgc3RyZWFtRGF0YSEsXG4gICAgICAgICAgICAgIGV4dHJhTWV0YWRhdGFSZWYsXG4gICAgICAgICAgICAgIG1lc3NhZ2VzUmVmLFxuICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXJSZWYsXG4gICAgICAgICAgICAgIGdlbmVyYXRlSWQsXG4gICAgICAgICAgICAgIHN0cmVhbU1vZGUsXG4gICAgICAgICAgICAgIG9uRmluaXNoLFxuICAgICAgICAgICAgICBvblJlc3BvbnNlLFxuICAgICAgICAgICAgICBzZW5kRXh0cmFNZXNzYWdlRmllbGRzLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwsXG4gICAgICAgICAgZXhwZXJpbWVudGFsX29uVG9vbENhbGwsXG4gICAgICAgICAgdXBkYXRlQ2hhdFJlcXVlc3Q6IGNoYXRSZXF1ZXN0UGFyYW0gPT4ge1xuICAgICAgICAgICAgY2hhdFJlcXVlc3QgPSBjaGF0UmVxdWVzdFBhcmFtO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0Q3VycmVudE1lc3NhZ2VzOiAoKSA9PiBtZXNzYWdlc1JlZi5jdXJyZW50LFxuICAgICAgICB9KTtcblxuICAgICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gSWdub3JlIGFib3J0IGVycm9ycyBhcyB0aGV5IGFyZSBleHBlY3RlZC5cbiAgICAgICAgaWYgKChlcnIgYXMgYW55KS5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob25FcnJvciAmJiBlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldEVycm9yKGVyciBhcyBFcnJvcik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBtdXRhdGVMb2FkaW5nKGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgLy8gYXV0by1zdWJtaXQgd2hlbiBhbGwgdG9vbCBjYWxscyBpbiB0aGUgbGFzdCBhc3Npc3RhbnQgbWVzc2FnZSBoYXZlIHJlc3VsdHM6XG4gICAgICBjb25zdCBtZXNzYWdlcyA9IG1lc3NhZ2VzUmVmLmN1cnJlbnQ7XG4gICAgICBjb25zdCBsYXN0TWVzc2FnZSA9IG1lc3NhZ2VzW21lc3NhZ2VzLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKFxuICAgICAgICAvLyBlbnN1cmUgdGhlcmUgaXMgYSBsYXN0IG1lc3NhZ2U6XG4gICAgICAgIGxhc3RNZXNzYWdlICE9IG51bGwgJiZcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGZlYXR1cmUgaXMgZW5hYmxlZDpcbiAgICAgICAgZXhwZXJpbWVudGFsX21heEF1dG9tYXRpY1JvdW5kdHJpcHMgPiAwICYmXG4gICAgICAgIC8vIGNoZWNrIHRoYXQgcm91bmR0cmlwIGlzIHBvc3NpYmxlOlxuICAgICAgICBpc0Fzc2lzdGFudE1lc3NhZ2VXaXRoQ29tcGxldGVkVG9vbENhbGxzKGxhc3RNZXNzYWdlKSAmJlxuICAgICAgICAvLyBsaW1pdCB0aGUgbnVtYmVyIG9mIGF1dG9tYXRpYyByb3VuZHRyaXBzOlxuICAgICAgICBjb3VudFRyYWlsaW5nQXNzaXN0YW50TWVzc2FnZXMobWVzc2FnZXMpIDw9XG4gICAgICAgICAgZXhwZXJpbWVudGFsX21heEF1dG9tYXRpY1JvdW5kdHJpcHNcbiAgICAgICkge1xuICAgICAgICBhd2FpdCB0cmlnZ2VyUmVxdWVzdCh7IG1lc3NhZ2VzIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgW1xuICAgICAgbXV0YXRlLFxuICAgICAgbXV0YXRlTG9hZGluZyxcbiAgICAgIGFwaSxcbiAgICAgIGV4dHJhTWV0YWRhdGFSZWYsXG4gICAgICBvblJlc3BvbnNlLFxuICAgICAgb25GaW5pc2gsXG4gICAgICBvbkVycm9yLFxuICAgICAgc2V0RXJyb3IsXG4gICAgICBtdXRhdGVTdHJlYW1EYXRhLFxuICAgICAgc3RyZWFtRGF0YSxcbiAgICAgIHN0cmVhbU1vZGUsXG4gICAgICBzZW5kRXh0cmFNZXNzYWdlRmllbGRzLFxuICAgICAgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsLFxuICAgICAgZXhwZXJpbWVudGFsX29uVG9vbENhbGwsXG4gICAgICBleHBlcmltZW50YWxfbWF4QXV0b21hdGljUm91bmR0cmlwcyxcbiAgICAgIG1lc3NhZ2VzUmVmLFxuICAgICAgYWJvcnRDb250cm9sbGVyUmVmLFxuICAgICAgZ2VuZXJhdGVJZCxcbiAgICBdLFxuICApO1xuXG4gIGNvbnN0IGFwcGVuZCA9IHVzZUNhbGxiYWNrKFxuICAgIGFzeW5jIChcbiAgICAgIG1lc3NhZ2U6IE1lc3NhZ2UgfCBDcmVhdGVNZXNzYWdlLFxuICAgICAge1xuICAgICAgICBvcHRpb25zLFxuICAgICAgICBmdW5jdGlvbnMsXG4gICAgICAgIGZ1bmN0aW9uX2NhbGwsXG4gICAgICAgIHRvb2xzLFxuICAgICAgICB0b29sX2Nob2ljZSxcbiAgICAgICAgZGF0YSxcbiAgICAgIH06IENoYXRSZXF1ZXN0T3B0aW9ucyA9IHt9LFxuICAgICkgPT4ge1xuICAgICAgaWYgKCFtZXNzYWdlLmlkKSB7XG4gICAgICAgIG1lc3NhZ2UuaWQgPSBnZW5lcmF0ZUlkKCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNoYXRSZXF1ZXN0OiBDaGF0UmVxdWVzdCA9IHtcbiAgICAgICAgbWVzc2FnZXM6IG1lc3NhZ2VzUmVmLmN1cnJlbnQuY29uY2F0KG1lc3NhZ2UgYXMgTWVzc2FnZSksXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIC4uLihmdW5jdGlvbnMgIT09IHVuZGVmaW5lZCAmJiB7IGZ1bmN0aW9ucyB9KSxcbiAgICAgICAgLi4uKGZ1bmN0aW9uX2NhbGwgIT09IHVuZGVmaW5lZCAmJiB7IGZ1bmN0aW9uX2NhbGwgfSksXG4gICAgICAgIC4uLih0b29scyAhPT0gdW5kZWZpbmVkICYmIHsgdG9vbHMgfSksXG4gICAgICAgIC4uLih0b29sX2Nob2ljZSAhPT0gdW5kZWZpbmVkICYmIHsgdG9vbF9jaG9pY2UgfSksXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gdHJpZ2dlclJlcXVlc3QoY2hhdFJlcXVlc3QpO1xuICAgIH0sXG4gICAgW3RyaWdnZXJSZXF1ZXN0LCBnZW5lcmF0ZUlkXSxcbiAgKTtcblxuICBjb25zdCByZWxvYWQgPSB1c2VDYWxsYmFjayhcbiAgICBhc3luYyAoe1xuICAgICAgb3B0aW9ucyxcbiAgICAgIGZ1bmN0aW9ucyxcbiAgICAgIGZ1bmN0aW9uX2NhbGwsXG4gICAgICB0b29scyxcbiAgICAgIHRvb2xfY2hvaWNlLFxuICAgIH06IENoYXRSZXF1ZXN0T3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICBpZiAobWVzc2FnZXNSZWYuY3VycmVudC5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gICAgICAvLyBSZW1vdmUgbGFzdCBhc3Npc3RhbnQgbWVzc2FnZSBhbmQgcmV0cnkgbGFzdCB1c2VyIG1lc3NhZ2UuXG4gICAgICBjb25zdCBsYXN0TWVzc2FnZSA9IG1lc3NhZ2VzUmVmLmN1cnJlbnRbbWVzc2FnZXNSZWYuY3VycmVudC5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChsYXN0TWVzc2FnZS5yb2xlID09PSAnYXNzaXN0YW50Jykge1xuICAgICAgICBjb25zdCBjaGF0UmVxdWVzdDogQ2hhdFJlcXVlc3QgPSB7XG4gICAgICAgICAgbWVzc2FnZXM6IG1lc3NhZ2VzUmVmLmN1cnJlbnQuc2xpY2UoMCwgLTEpLFxuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgLi4uKGZ1bmN0aW9ucyAhPT0gdW5kZWZpbmVkICYmIHsgZnVuY3Rpb25zIH0pLFxuICAgICAgICAgIC4uLihmdW5jdGlvbl9jYWxsICE9PSB1bmRlZmluZWQgJiYgeyBmdW5jdGlvbl9jYWxsIH0pLFxuICAgICAgICAgIC4uLih0b29scyAhPT0gdW5kZWZpbmVkICYmIHsgdG9vbHMgfSksXG4gICAgICAgICAgLi4uKHRvb2xfY2hvaWNlICE9PSB1bmRlZmluZWQgJiYgeyB0b29sX2Nob2ljZSB9KSxcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdHJpZ2dlclJlcXVlc3QoY2hhdFJlcXVlc3QpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjaGF0UmVxdWVzdDogQ2hhdFJlcXVlc3QgPSB7XG4gICAgICAgIG1lc3NhZ2VzOiBtZXNzYWdlc1JlZi5jdXJyZW50LFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICAuLi4oZnVuY3Rpb25zICE9PSB1bmRlZmluZWQgJiYgeyBmdW5jdGlvbnMgfSksXG4gICAgICAgIC4uLihmdW5jdGlvbl9jYWxsICE9PSB1bmRlZmluZWQgJiYgeyBmdW5jdGlvbl9jYWxsIH0pLFxuICAgICAgICAuLi4odG9vbHMgIT09IHVuZGVmaW5lZCAmJiB7IHRvb2xzIH0pLFxuICAgICAgICAuLi4odG9vbF9jaG9pY2UgIT09IHVuZGVmaW5lZCAmJiB7IHRvb2xfY2hvaWNlIH0pLFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHRyaWdnZXJSZXF1ZXN0KGNoYXRSZXF1ZXN0KTtcbiAgICB9LFxuICAgIFt0cmlnZ2VyUmVxdWVzdF0sXG4gICk7XG5cbiAgY29uc3Qgc3RvcCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQpIHtcbiAgICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50LmFib3J0KCk7XG4gICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9LCBbXSk7XG5cbiAgY29uc3Qgc2V0TWVzc2FnZXMgPSB1c2VDYWxsYmFjayhcbiAgICAobWVzc2FnZXM6IE1lc3NhZ2VbXSkgPT4ge1xuICAgICAgbXV0YXRlKG1lc3NhZ2VzLCBmYWxzZSk7XG4gICAgICBtZXNzYWdlc1JlZi5jdXJyZW50ID0gbWVzc2FnZXM7XG4gICAgfSxcbiAgICBbbXV0YXRlXSxcbiAgKTtcblxuICAvLyBJbnB1dCBzdGF0ZSBhbmQgaGFuZGxlcnMuXG4gIGNvbnN0IFtpbnB1dCwgc2V0SW5wdXRdID0gdXNlU3RhdGUoaW5pdGlhbElucHV0KTtcblxuICBjb25zdCBoYW5kbGVTdWJtaXQgPSB1c2VDYWxsYmFjayhcbiAgICAoXG4gICAgICBlOiBSZWFjdC5Gb3JtRXZlbnQ8SFRNTEZvcm1FbGVtZW50PixcbiAgICAgIG9wdGlvbnM6IENoYXRSZXF1ZXN0T3B0aW9ucyA9IHt9LFxuICAgICAgbWV0YWRhdGE/OiBPYmplY3QsXG4gICAgKSA9PiB7XG4gICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50ID0ge1xuICAgICAgICAgIC4uLmV4dHJhTWV0YWRhdGFSZWYuY3VycmVudCxcbiAgICAgICAgICAuLi5tZXRhZGF0YSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaWYgKCFpbnB1dCkgcmV0dXJuO1xuXG4gICAgICBhcHBlbmQoXG4gICAgICAgIHtcbiAgICAgICAgICBjb250ZW50OiBpbnB1dCxcbiAgICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgICB9LFxuICAgICAgICBvcHRpb25zLFxuICAgICAgKTtcbiAgICAgIHNldElucHV0KCcnKTtcbiAgICB9LFxuICAgIFtpbnB1dCwgYXBwZW5kXSxcbiAgKTtcblxuICBjb25zdCBoYW5kbGVJbnB1dENoYW5nZSA9IChlOiBhbnkpID0+IHtcbiAgICBzZXRJbnB1dChlLnRhcmdldC52YWx1ZSk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBtZXNzYWdlczogbWVzc2FnZXMgfHwgW10sXG4gICAgZXJyb3IsXG4gICAgYXBwZW5kLFxuICAgIHJlbG9hZCxcbiAgICBzdG9wLFxuICAgIHNldE1lc3NhZ2VzLFxuICAgIGlucHV0LFxuICAgIHNldElucHV0LFxuICAgIGhhbmRsZUlucHV0Q2hhbmdlLFxuICAgIGhhbmRsZVN1Ym1pdCxcbiAgICBpc0xvYWRpbmcsXG4gICAgZGF0YTogc3RyZWFtRGF0YSxcbiAgICBleHBlcmltZW50YWxfYWRkVG9vbFJlc3VsdDogKHtcbiAgICAgIHRvb2xDYWxsSWQsXG4gICAgICByZXN1bHQsXG4gICAgfToge1xuICAgICAgdG9vbENhbGxJZDogc3RyaW5nO1xuICAgICAgcmVzdWx0OiBhbnk7XG4gICAgfSkgPT4ge1xuICAgICAgY29uc3QgdXBkYXRlZE1lc3NhZ2VzID0gbWVzc2FnZXNSZWYuY3VycmVudC5tYXAoKG1lc3NhZ2UsIGluZGV4LCBhcnIpID0+XG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgdG9vbCBjYWxscyBpbiB0aGUgbGFzdCBhc3Npc3RhbnQgbWVzc2FnZTpcbiAgICAgICAgaW5kZXggPT09IGFyci5sZW5ndGggLSAxICYmXG4gICAgICAgIG1lc3NhZ2Uucm9sZSA9PT0gJ2Fzc2lzdGFudCcgJiZcbiAgICAgICAgbWVzc2FnZS50b29sSW52b2NhdGlvbnNcbiAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgLi4ubWVzc2FnZSxcbiAgICAgICAgICAgICAgdG9vbEludm9jYXRpb25zOiBtZXNzYWdlLnRvb2xJbnZvY2F0aW9ucy5tYXAodG9vbEludm9jYXRpb24gPT5cbiAgICAgICAgICAgICAgICB0b29sSW52b2NhdGlvbi50b29sQ2FsbElkID09PSB0b29sQ2FsbElkXG4gICAgICAgICAgICAgICAgICA/IHsgLi4udG9vbEludm9jYXRpb24sIHJlc3VsdCB9XG4gICAgICAgICAgICAgICAgICA6IHRvb2xJbnZvY2F0aW9uLFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIDogbWVzc2FnZSxcbiAgICAgICk7XG5cbiAgICAgIG11dGF0ZSh1cGRhdGVkTWVzc2FnZXMsIGZhbHNlKTtcblxuICAgICAgLy8gYXV0by1zdWJtaXQgd2hlbiBhbGwgdG9vbCBjYWxscyBpbiB0aGUgbGFzdCBhc3Npc3RhbnQgbWVzc2FnZSBoYXZlIHJlc3VsdHM6XG4gICAgICBjb25zdCBsYXN0TWVzc2FnZSA9IHVwZGF0ZWRNZXNzYWdlc1t1cGRhdGVkTWVzc2FnZXMubGVuZ3RoIC0gMV07XG4gICAgICBpZiAoaXNBc3Npc3RhbnRNZXNzYWdlV2l0aENvbXBsZXRlZFRvb2xDYWxscyhsYXN0TWVzc2FnZSkpIHtcbiAgICAgICAgdHJpZ2dlclJlcXVlc3QoeyBtZXNzYWdlczogdXBkYXRlZE1lc3NhZ2VzIH0pO1xuICAgICAgfVxuICAgIH0sXG4gIH07XG59XG5cbi8qKlxuQ2hlY2sgaWYgdGhlIG1lc3NhZ2UgaXMgYW4gYXNzaXN0YW50IG1lc3NhZ2Ugd2l0aCBjb21wbGV0ZWQgdG9vbCBjYWxscy4gXG5UaGUgbWVzc2FnZSBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIHRvb2wgaW52b2NhdGlvbiBhbmQgYWxsIHRvb2wgaW52b2NhdGlvbnNcbm11c3QgaGF2ZSBhIHJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gaXNBc3Npc3RhbnRNZXNzYWdlV2l0aENvbXBsZXRlZFRvb2xDYWxscyhtZXNzYWdlOiBNZXNzYWdlKSB7XG4gIHJldHVybiAoXG4gICAgbWVzc2FnZS5yb2xlID09PSAnYXNzaXN0YW50JyAmJlxuICAgIG1lc3NhZ2UudG9vbEludm9jYXRpb25zICYmXG4gICAgbWVzc2FnZS50b29sSW52b2NhdGlvbnMubGVuZ3RoID4gMCAmJlxuICAgIG1lc3NhZ2UudG9vbEludm9jYXRpb25zLmV2ZXJ5KHRvb2xJbnZvY2F0aW9uID0+ICdyZXN1bHQnIGluIHRvb2xJbnZvY2F0aW9uKVxuICApO1xufVxuXG4vKipcblJldHVybnMgdGhlIG51bWJlciBvZiB0cmFpbGluZyBhc3Npc3RhbnQgbWVzc2FnZXMgaW4gdGhlIGFycmF5LlxuICovXG5mdW5jdGlvbiBjb3VudFRyYWlsaW5nQXNzaXN0YW50TWVzc2FnZXMobWVzc2FnZXM6IE1lc3NhZ2VbXSkge1xuICBsZXQgY291bnQgPSAwO1xuICBmb3IgKGxldCBpID0gbWVzc2FnZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAobWVzc2FnZXNbaV0ucm9sZSA9PT0gJ2Fzc2lzdGFudCcpIHtcbiAgICAgIGNvdW50Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY291bnQ7XG59XG4iLCJpbXBvcnQgeyBjdXN0b21BbHBoYWJldCB9IGZyb20gJ25hbm9pZC9ub24tc2VjdXJlJztcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSA3LWNoYXJhY3RlciByYW5kb20gc3RyaW5nIHRvIHVzZSBmb3IgSURzLiBOb3Qgc2VjdXJlLlxuICovXG5leHBvcnQgY29uc3QgZ2VuZXJhdGVJZCA9IGN1c3RvbUFscGhhYmV0KFxuICAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonLFxuICA3LFxuKTtcbiIsImltcG9ydCB7IFRvb2xDYWxsIGFzIENvcmVUb29sQ2FsbCB9IGZyb20gJy4uL2NvcmUvZ2VuZXJhdGUtdGV4dC90b29sLWNhbGwnO1xuaW1wb3J0IHsgVG9vbFJlc3VsdCBhcyBDb3JlVG9vbFJlc3VsdCB9IGZyb20gJy4uL2NvcmUvZ2VuZXJhdGUtdGV4dC90b29sLXJlc3VsdCc7XG5pbXBvcnQge1xuICBBc3Npc3RhbnRNZXNzYWdlLFxuICBEYXRhTWVzc2FnZSxcbiAgRnVuY3Rpb25DYWxsLFxuICBKU09OVmFsdWUsXG4gIFRvb2xDYWxsLFxufSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IFN0cmVhbVN0cmluZyB9IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFN0cmVhbVBhcnQ8Q09ERSBleHRlbmRzIHN0cmluZywgTkFNRSBleHRlbmRzIHN0cmluZywgVFlQRT4ge1xuICBjb2RlOiBDT0RFO1xuICBuYW1lOiBOQU1FO1xuICBwYXJzZTogKHZhbHVlOiBKU09OVmFsdWUpID0+IHsgdHlwZTogTkFNRTsgdmFsdWU6IFRZUEUgfTtcbn1cblxuY29uc3QgdGV4dFN0cmVhbVBhcnQ6IFN0cmVhbVBhcnQ8JzAnLCAndGV4dCcsIHN0cmluZz4gPSB7XG4gIGNvZGU6ICcwJyxcbiAgbmFtZTogJ3RleHQnLFxuICBwYXJzZTogKHZhbHVlOiBKU09OVmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcInRleHRcIiBwYXJ0cyBleHBlY3QgYSBzdHJpbmcgdmFsdWUuJyk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6ICd0ZXh0JywgdmFsdWUgfTtcbiAgfSxcbn07XG5cbmNvbnN0IGZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQ6IFN0cmVhbVBhcnQ8XG4gICcxJyxcbiAgJ2Z1bmN0aW9uX2NhbGwnLFxuICB7IGZ1bmN0aW9uX2NhbGw6IEZ1bmN0aW9uQ2FsbCB9XG4+ID0ge1xuICBjb2RlOiAnMScsXG4gIG5hbWU6ICdmdW5jdGlvbl9jYWxsJyxcbiAgcGFyc2U6ICh2YWx1ZTogSlNPTlZhbHVlKSA9PiB7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fFxuICAgICAgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fFxuICAgICAgISgnZnVuY3Rpb25fY2FsbCcgaW4gdmFsdWUpIHx8XG4gICAgICB0eXBlb2YgdmFsdWUuZnVuY3Rpb25fY2FsbCAhPT0gJ29iamVjdCcgfHxcbiAgICAgIHZhbHVlLmZ1bmN0aW9uX2NhbGwgPT0gbnVsbCB8fFxuICAgICAgISgnbmFtZScgaW4gdmFsdWUuZnVuY3Rpb25fY2FsbCkgfHxcbiAgICAgICEoJ2FyZ3VtZW50cycgaW4gdmFsdWUuZnVuY3Rpb25fY2FsbCkgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZS5mdW5jdGlvbl9jYWxsLm5hbWUgIT09ICdzdHJpbmcnIHx8XG4gICAgICB0eXBlb2YgdmFsdWUuZnVuY3Rpb25fY2FsbC5hcmd1bWVudHMgIT09ICdzdHJpbmcnXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImZ1bmN0aW9uX2NhbGxcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcImZ1bmN0aW9uX2NhbGxcIiBwcm9wZXJ0eS4nLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2Z1bmN0aW9uX2NhbGwnLFxuICAgICAgdmFsdWU6IHZhbHVlIGFzIHVua25vd24gYXMgeyBmdW5jdGlvbl9jYWxsOiBGdW5jdGlvbkNhbGwgfSxcbiAgICB9O1xuICB9LFxufTtcblxuY29uc3QgZGF0YVN0cmVhbVBhcnQ6IFN0cmVhbVBhcnQ8JzInLCAnZGF0YScsIEFycmF5PEpTT05WYWx1ZT4+ID0ge1xuICBjb2RlOiAnMicsXG4gIG5hbWU6ICdkYXRhJyxcbiAgcGFyc2U6ICh2YWx1ZTogSlNPTlZhbHVlKSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImRhdGFcIiBwYXJ0cyBleHBlY3QgYW4gYXJyYXkgdmFsdWUuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgdHlwZTogJ2RhdGEnLCB2YWx1ZSB9O1xuICB9LFxufTtcblxuY29uc3QgZXJyb3JTdHJlYW1QYXJ0OiBTdHJlYW1QYXJ0PCczJywgJ2Vycm9yJywgc3RyaW5nPiA9IHtcbiAgY29kZTogJzMnLFxuICBuYW1lOiAnZXJyb3InLFxuICBwYXJzZTogKHZhbHVlOiBKU09OVmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImVycm9yXCIgcGFydHMgZXhwZWN0IGEgc3RyaW5nIHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiAnZXJyb3InLCB2YWx1ZSB9O1xuICB9LFxufTtcblxuY29uc3QgYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQ6IFN0cmVhbVBhcnQ8XG4gICc0JyxcbiAgJ2Fzc2lzdGFudF9tZXNzYWdlJyxcbiAgQXNzaXN0YW50TWVzc2FnZVxuPiA9IHtcbiAgY29kZTogJzQnLFxuICBuYW1lOiAnYXNzaXN0YW50X21lc3NhZ2UnLFxuICBwYXJzZTogKHZhbHVlOiBKU09OVmFsdWUpID0+IHtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSA9PSBudWxsIHx8XG4gICAgICB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8XG4gICAgICAhKCdpZCcgaW4gdmFsdWUpIHx8XG4gICAgICAhKCdyb2xlJyBpbiB2YWx1ZSkgfHxcbiAgICAgICEoJ2NvbnRlbnQnIGluIHZhbHVlKSB8fFxuICAgICAgdHlwZW9mIHZhbHVlLmlkICE9PSAnc3RyaW5nJyB8fFxuICAgICAgdHlwZW9mIHZhbHVlLnJvbGUgIT09ICdzdHJpbmcnIHx8XG4gICAgICB2YWx1ZS5yb2xlICE9PSAnYXNzaXN0YW50JyB8fFxuICAgICAgIUFycmF5LmlzQXJyYXkodmFsdWUuY29udGVudCkgfHxcbiAgICAgICF2YWx1ZS5jb250ZW50LmV2ZXJ5KFxuICAgICAgICBpdGVtID0+XG4gICAgICAgICAgaXRlbSAhPSBudWxsICYmXG4gICAgICAgICAgdHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgJ3R5cGUnIGluIGl0ZW0gJiZcbiAgICAgICAgICBpdGVtLnR5cGUgPT09ICd0ZXh0JyAmJlxuICAgICAgICAgICd0ZXh0JyBpbiBpdGVtICYmXG4gICAgICAgICAgaXRlbS50ZXh0ICE9IG51bGwgJiZcbiAgICAgICAgICB0eXBlb2YgaXRlbS50ZXh0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICd2YWx1ZScgaW4gaXRlbS50ZXh0ICYmXG4gICAgICAgICAgdHlwZW9mIGl0ZW0udGV4dC52YWx1ZSA9PT0gJ3N0cmluZycsXG4gICAgICApXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImFzc2lzdGFudF9tZXNzYWdlXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGFuIFwiaWRcIiwgXCJyb2xlXCIsIGFuZCBcImNvbnRlbnRcIiBwcm9wZXJ0eS4nLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2Fzc2lzdGFudF9tZXNzYWdlJyxcbiAgICAgIHZhbHVlOiB2YWx1ZSBhcyBBc3Npc3RhbnRNZXNzYWdlLFxuICAgIH07XG4gIH0sXG59O1xuXG5jb25zdCBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQ6IFN0cmVhbVBhcnQ8XG4gICc1JyxcbiAgJ2Fzc2lzdGFudF9jb250cm9sX2RhdGEnLFxuICB7XG4gICAgdGhyZWFkSWQ6IHN0cmluZztcbiAgICBtZXNzYWdlSWQ6IHN0cmluZztcbiAgfVxuPiA9IHtcbiAgY29kZTogJzUnLFxuICBuYW1lOiAnYXNzaXN0YW50X2NvbnRyb2xfZGF0YScsXG4gIHBhcnNlOiAodmFsdWU6IEpTT05WYWx1ZSkgPT4ge1xuICAgIGlmIChcbiAgICAgIHZhbHVlID09IG51bGwgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICEoJ3RocmVhZElkJyBpbiB2YWx1ZSkgfHxcbiAgICAgICEoJ21lc3NhZ2VJZCcgaW4gdmFsdWUpIHx8XG4gICAgICB0eXBlb2YgdmFsdWUudGhyZWFkSWQgIT09ICdzdHJpbmcnIHx8XG4gICAgICB0eXBlb2YgdmFsdWUubWVzc2FnZUlkICE9PSAnc3RyaW5nJ1xuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJhc3Npc3RhbnRfY29udHJvbF9kYXRhXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJ0aHJlYWRJZFwiIGFuZCBcIm1lc3NhZ2VJZFwiIHByb3BlcnR5LicsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnYXNzaXN0YW50X2NvbnRyb2xfZGF0YScsXG4gICAgICB2YWx1ZToge1xuICAgICAgICB0aHJlYWRJZDogdmFsdWUudGhyZWFkSWQsXG4gICAgICAgIG1lc3NhZ2VJZDogdmFsdWUubWVzc2FnZUlkLFxuICAgICAgfSxcbiAgICB9O1xuICB9LFxufTtcblxuY29uc3QgZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0OiBTdHJlYW1QYXJ0PCc2JywgJ2RhdGFfbWVzc2FnZScsIERhdGFNZXNzYWdlPiA9IHtcbiAgY29kZTogJzYnLFxuICBuYW1lOiAnZGF0YV9tZXNzYWdlJyxcbiAgcGFyc2U6ICh2YWx1ZTogSlNPTlZhbHVlKSA9PiB7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fFxuICAgICAgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fFxuICAgICAgISgncm9sZScgaW4gdmFsdWUpIHx8XG4gICAgICAhKCdkYXRhJyBpbiB2YWx1ZSkgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZS5yb2xlICE9PSAnc3RyaW5nJyB8fFxuICAgICAgdmFsdWUucm9sZSAhPT0gJ2RhdGEnXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImRhdGFfbWVzc2FnZVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwicm9sZVwiIGFuZCBcImRhdGFcIiBwcm9wZXJ0eS4nLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2RhdGFfbWVzc2FnZScsXG4gICAgICB2YWx1ZTogdmFsdWUgYXMgRGF0YU1lc3NhZ2UsXG4gICAgfTtcbiAgfSxcbn07XG5cbmNvbnN0IHRvb2xDYWxsc1N0cmVhbVBhcnQ6IFN0cmVhbVBhcnQ8XG4gICc3JyxcbiAgJ3Rvb2xfY2FsbHMnLFxuICB7IHRvb2xfY2FsbHM6IFRvb2xDYWxsW10gfVxuPiA9IHtcbiAgY29kZTogJzcnLFxuICBuYW1lOiAndG9vbF9jYWxscycsXG4gIHBhcnNlOiAodmFsdWU6IEpTT05WYWx1ZSkgPT4ge1xuICAgIGlmIChcbiAgICAgIHZhbHVlID09IG51bGwgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICEoJ3Rvb2xfY2FsbHMnIGluIHZhbHVlKSB8fFxuICAgICAgdHlwZW9mIHZhbHVlLnRvb2xfY2FsbHMgIT09ICdvYmplY3QnIHx8XG4gICAgICB2YWx1ZS50b29sX2NhbGxzID09IG51bGwgfHxcbiAgICAgICFBcnJheS5pc0FycmF5KHZhbHVlLnRvb2xfY2FsbHMpIHx8XG4gICAgICB2YWx1ZS50b29sX2NhbGxzLnNvbWUoXG4gICAgICAgIHRjID0+XG4gICAgICAgICAgdGMgPT0gbnVsbCB8fFxuICAgICAgICAgIHR5cGVvZiB0YyAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAhKCdpZCcgaW4gdGMpIHx8XG4gICAgICAgICAgdHlwZW9mIHRjLmlkICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICEoJ3R5cGUnIGluIHRjKSB8fFxuICAgICAgICAgIHR5cGVvZiB0Yy50eXBlICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICEoJ2Z1bmN0aW9uJyBpbiB0YykgfHxcbiAgICAgICAgICB0Yy5mdW5jdGlvbiA9PSBudWxsIHx8XG4gICAgICAgICAgdHlwZW9mIHRjLmZ1bmN0aW9uICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICEoJ2FyZ3VtZW50cycgaW4gdGMuZnVuY3Rpb24pIHx8XG4gICAgICAgICAgdHlwZW9mIHRjLmZ1bmN0aW9uLm5hbWUgIT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgdHlwZW9mIHRjLmZ1bmN0aW9uLmFyZ3VtZW50cyAhPT0gJ3N0cmluZycsXG4gICAgICApXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcInRvb2xfY2FsbHNcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBUb29sQ2FsbFBheWxvYWQuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICd0b29sX2NhbGxzJyxcbiAgICAgIHZhbHVlOiB2YWx1ZSBhcyB1bmtub3duIGFzIHsgdG9vbF9jYWxsczogVG9vbENhbGxbXSB9LFxuICAgIH07XG4gIH0sXG59O1xuXG5jb25zdCBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0OiBTdHJlYW1QYXJ0PFxuICAnOCcsXG4gICdtZXNzYWdlX2Fubm90YXRpb25zJyxcbiAgQXJyYXk8SlNPTlZhbHVlPlxuPiA9IHtcbiAgY29kZTogJzgnLFxuICBuYW1lOiAnbWVzc2FnZV9hbm5vdGF0aW9ucycsXG4gIHBhcnNlOiAodmFsdWU6IEpTT05WYWx1ZSkgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJtZXNzYWdlX2Fubm90YXRpb25zXCIgcGFydHMgZXhwZWN0IGFuIGFycmF5IHZhbHVlLicpO1xuICAgIH1cblxuICAgIHJldHVybiB7IHR5cGU6ICdtZXNzYWdlX2Fubm90YXRpb25zJywgdmFsdWUgfTtcbiAgfSxcbn07XG5cbmNvbnN0IHRvb2xDYWxsU3RyZWFtUGFydDogU3RyZWFtUGFydDxcbiAgJzknLFxuICAndG9vbF9jYWxsJyxcbiAgQ29yZVRvb2xDYWxsPHN0cmluZywgYW55PlxuPiA9IHtcbiAgY29kZTogJzknLFxuICBuYW1lOiAndG9vbF9jYWxsJyxcbiAgcGFyc2U6ICh2YWx1ZTogSlNPTlZhbHVlKSA9PiB7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fFxuICAgICAgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fFxuICAgICAgISgndG9vbENhbGxJZCcgaW4gdmFsdWUpIHx8XG4gICAgICB0eXBlb2YgdmFsdWUudG9vbENhbGxJZCAhPT0gJ3N0cmluZycgfHxcbiAgICAgICEoJ3Rvb2xOYW1lJyBpbiB2YWx1ZSkgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZS50b29sTmFtZSAhPT0gJ3N0cmluZycgfHxcbiAgICAgICEoJ2FyZ3MnIGluIHZhbHVlKSB8fFxuICAgICAgdHlwZW9mIHZhbHVlLmFyZ3MgIT09ICdvYmplY3QnXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcInRvb2xfY2FsbFwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwidG9vbENhbGxJZFwiLCBcInRvb2xOYW1lXCIsIGFuZCBcImFyZ3NcIiBwcm9wZXJ0eS4nLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ3Rvb2xfY2FsbCcsXG4gICAgICB2YWx1ZTogdmFsdWUgYXMgdW5rbm93biBhcyBDb3JlVG9vbENhbGw8c3RyaW5nLCBhbnk+LFxuICAgIH07XG4gIH0sXG59O1xuXG5jb25zdCB0b29sUmVzdWx0U3RyZWFtUGFydDogU3RyZWFtUGFydDxcbiAgJ2EnLFxuICAndG9vbF9yZXN1bHQnLFxuICBDb3JlVG9vbFJlc3VsdDxzdHJpbmcsIGFueSwgYW55PlxuPiA9IHtcbiAgY29kZTogJ2EnLFxuICBuYW1lOiAndG9vbF9yZXN1bHQnLFxuICBwYXJzZTogKHZhbHVlOiBKU09OVmFsdWUpID0+IHtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSA9PSBudWxsIHx8XG4gICAgICB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8XG4gICAgICAhKCd0b29sQ2FsbElkJyBpbiB2YWx1ZSkgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZS50b29sQ2FsbElkICE9PSAnc3RyaW5nJyB8fFxuICAgICAgISgndG9vbE5hbWUnIGluIHZhbHVlKSB8fFxuICAgICAgdHlwZW9mIHZhbHVlLnRvb2xOYW1lICE9PSAnc3RyaW5nJyB8fFxuICAgICAgISgnYXJncycgaW4gdmFsdWUpIHx8XG4gICAgICB0eXBlb2YgdmFsdWUuYXJncyAhPT0gJ29iamVjdCcgfHxcbiAgICAgICEoJ3Jlc3VsdCcgaW4gdmFsdWUpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcInRvb2xfcmVzdWx0XCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJ0b29sQ2FsbElkXCIsIFwidG9vbE5hbWVcIiwgXCJhcmdzXCIsIGFuZCBcInJlc3VsdFwiIHByb3BlcnR5LicsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAndG9vbF9yZXN1bHQnLFxuICAgICAgdmFsdWU6IHZhbHVlIGFzIHVua25vd24gYXMgQ29yZVRvb2xSZXN1bHQ8c3RyaW5nLCBhbnksIGFueT4sXG4gICAgfTtcbiAgfSxcbn07XG5cbmNvbnN0IHN0cmVhbVBhcnRzID0gW1xuICB0ZXh0U3RyZWFtUGFydCxcbiAgZnVuY3Rpb25DYWxsU3RyZWFtUGFydCxcbiAgZGF0YVN0cmVhbVBhcnQsXG4gIGVycm9yU3RyZWFtUGFydCxcbiAgYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQsXG4gIGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydCxcbiAgZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0LFxuICB0b29sQ2FsbHNTdHJlYW1QYXJ0LFxuICBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0LFxuICB0b29sQ2FsbFN0cmVhbVBhcnQsXG4gIHRvb2xSZXN1bHRTdHJlYW1QYXJ0LFxuXSBhcyBjb25zdDtcblxuLy8gdW5pb24gdHlwZSBvZiBhbGwgc3RyZWFtIHBhcnRzXG50eXBlIFN0cmVhbVBhcnRzID1cbiAgfCB0eXBlb2YgdGV4dFN0cmVhbVBhcnRcbiAgfCB0eXBlb2YgZnVuY3Rpb25DYWxsU3RyZWFtUGFydFxuICB8IHR5cGVvZiBkYXRhU3RyZWFtUGFydFxuICB8IHR5cGVvZiBlcnJvclN0cmVhbVBhcnRcbiAgfCB0eXBlb2YgYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnRcbiAgfCB0eXBlb2YgYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0XG4gIHwgdHlwZW9mIGRhdGFNZXNzYWdlU3RyZWFtUGFydFxuICB8IHR5cGVvZiB0b29sQ2FsbHNTdHJlYW1QYXJ0XG4gIHwgdHlwZW9mIG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnRcbiAgfCB0eXBlb2YgdG9vbENhbGxTdHJlYW1QYXJ0XG4gIHwgdHlwZW9mIHRvb2xSZXN1bHRTdHJlYW1QYXJ0O1xuXG4vKipcbiAqIE1hcHMgdGhlIHR5cGUgb2YgYSBzdHJlYW0gcGFydCB0byBpdHMgdmFsdWUgdHlwZS5cbiAqL1xudHlwZSBTdHJlYW1QYXJ0VmFsdWVUeXBlID0ge1xuICBbUCBpbiBTdHJlYW1QYXJ0cyBhcyBQWyduYW1lJ11dOiBSZXR1cm5UeXBlPFBbJ3BhcnNlJ10+Wyd2YWx1ZSddO1xufTtcblxuZXhwb3J0IHR5cGUgU3RyZWFtUGFydFR5cGUgPVxuICB8IFJldHVyblR5cGU8dHlwZW9mIHRleHRTdHJlYW1QYXJ0LnBhcnNlPlxuICB8IFJldHVyblR5cGU8dHlwZW9mIGZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQucGFyc2U+XG4gIHwgUmV0dXJuVHlwZTx0eXBlb2YgZGF0YVN0cmVhbVBhcnQucGFyc2U+XG4gIHwgUmV0dXJuVHlwZTx0eXBlb2YgZXJyb3JTdHJlYW1QYXJ0LnBhcnNlPlxuICB8IFJldHVyblR5cGU8dHlwZW9mIGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LnBhcnNlPlxuICB8IFJldHVyblR5cGU8dHlwZW9mIGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydC5wYXJzZT5cbiAgfCBSZXR1cm5UeXBlPHR5cGVvZiBkYXRhTWVzc2FnZVN0cmVhbVBhcnQucGFyc2U+XG4gIHwgUmV0dXJuVHlwZTx0eXBlb2YgdG9vbENhbGxzU3RyZWFtUGFydC5wYXJzZT5cbiAgfCBSZXR1cm5UeXBlPHR5cGVvZiBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0LnBhcnNlPlxuICB8IFJldHVyblR5cGU8dHlwZW9mIHRvb2xDYWxsU3RyZWFtUGFydC5wYXJzZT5cbiAgfCBSZXR1cm5UeXBlPHR5cGVvZiB0b29sUmVzdWx0U3RyZWFtUGFydC5wYXJzZT47XG5cbmV4cG9ydCBjb25zdCBzdHJlYW1QYXJ0c0J5Q29kZSA9IHtcbiAgW3RleHRTdHJlYW1QYXJ0LmNvZGVdOiB0ZXh0U3RyZWFtUGFydCxcbiAgW2Z1bmN0aW9uQ2FsbFN0cmVhbVBhcnQuY29kZV06IGZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQsXG4gIFtkYXRhU3RyZWFtUGFydC5jb2RlXTogZGF0YVN0cmVhbVBhcnQsXG4gIFtlcnJvclN0cmVhbVBhcnQuY29kZV06IGVycm9yU3RyZWFtUGFydCxcbiAgW2Fzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LmNvZGVdOiBhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydCxcbiAgW2Fzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydC5jb2RlXTogYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0LFxuICBbZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0LmNvZGVdOiBkYXRhTWVzc2FnZVN0cmVhbVBhcnQsXG4gIFt0b29sQ2FsbHNTdHJlYW1QYXJ0LmNvZGVdOiB0b29sQ2FsbHNTdHJlYW1QYXJ0LFxuICBbbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydC5jb2RlXTogbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydCxcbiAgW3Rvb2xDYWxsU3RyZWFtUGFydC5jb2RlXTogdG9vbENhbGxTdHJlYW1QYXJ0LFxuICBbdG9vbFJlc3VsdFN0cmVhbVBhcnQuY29kZV06IHRvb2xSZXN1bHRTdHJlYW1QYXJ0LFxufSBhcyBjb25zdDtcblxuLyoqXG4gKiBUaGUgbWFwIG9mIHByZWZpeGVzIGZvciBkYXRhIGluIHRoZSBzdHJlYW1cbiAqXG4gKiAtIDA6IFRleHQgZnJvbSB0aGUgTExNIHJlc3BvbnNlXG4gKiAtIDE6IChPcGVuQUkpIGZ1bmN0aW9uX2NhbGwgcmVzcG9uc2VzXG4gKiAtIDI6IGN1c3RvbSBKU09OIGFkZGVkIGJ5IHRoZSB1c2VyIHVzaW5nIGBEYXRhYFxuICogLSA2OiAoT3BlbkFJKSB0b29sX2NhbGwgcmVzcG9uc2VzXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYFxuICogMDpWZXJjZWxcbiAqIDA6J3NcbiAqIDA6IEFJXG4gKiAwOiBBSVxuICogMDogU0RLXG4gKiAwOiBpcyBncmVhdFxuICogMDohXG4gKiAyOiB7IFwic29tZUpzb25cIjogXCJ2YWx1ZVwiIH1cbiAqIDE6IHtcImZ1bmN0aW9uX2NhbGxcIjoge1wibmFtZVwiOiBcImdldF9jdXJyZW50X3dlYXRoZXJcIiwgXCJhcmd1bWVudHNcIjogXCJ7XFxcXG5cXFxcXCJsb2NhdGlvblxcXFxcIjogXFxcXFwiQ2hhcmxvdHRlc3ZpbGxlLCBWaXJnaW5pYVxcXFxcIixcXFxcblxcXFxcImZvcm1hdFxcXFxcIjogXFxcXFwiY2Vsc2l1c1xcXFxcIlxcXFxufVwifX1cbiAqIDY6IHtcInRvb2xfY2FsbFwiOiB7XCJpZFwiOiBcInRvb2xfMFwiLCBcInR5cGVcIjogXCJmdW5jdGlvblwiLCBcImZ1bmN0aW9uXCI6IHtcIm5hbWVcIjogXCJnZXRfY3VycmVudF93ZWF0aGVyXCIsIFwiYXJndW1lbnRzXCI6IFwie1xcXFxuXFxcXFwibG9jYXRpb25cXFxcXCI6IFxcXFxcIkNoYXJsb3R0ZXN2aWxsZSwgVmlyZ2luaWFcXFxcXCIsXFxcXG5cXFxcXCJmb3JtYXRcXFxcXCI6IFxcXFxcImNlbHNpdXNcXFxcXCJcXFxcbn1cIn19fVxuICpgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IFN0cmVhbVN0cmluZ1ByZWZpeGVzID0ge1xuICBbdGV4dFN0cmVhbVBhcnQubmFtZV06IHRleHRTdHJlYW1QYXJ0LmNvZGUsXG4gIFtmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0Lm5hbWVdOiBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0LmNvZGUsXG4gIFtkYXRhU3RyZWFtUGFydC5uYW1lXTogZGF0YVN0cmVhbVBhcnQuY29kZSxcbiAgW2Vycm9yU3RyZWFtUGFydC5uYW1lXTogZXJyb3JTdHJlYW1QYXJ0LmNvZGUsXG4gIFthc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydC5uYW1lXTogYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQuY29kZSxcbiAgW2Fzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydC5uYW1lXTogYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0LmNvZGUsXG4gIFtkYXRhTWVzc2FnZVN0cmVhbVBhcnQubmFtZV06IGRhdGFNZXNzYWdlU3RyZWFtUGFydC5jb2RlLFxuICBbdG9vbENhbGxzU3RyZWFtUGFydC5uYW1lXTogdG9vbENhbGxzU3RyZWFtUGFydC5jb2RlLFxuICBbbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydC5uYW1lXTogbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydC5jb2RlLFxuICBbdG9vbENhbGxTdHJlYW1QYXJ0Lm5hbWVdOiB0b29sQ2FsbFN0cmVhbVBhcnQuY29kZSxcbiAgW3Rvb2xSZXN1bHRTdHJlYW1QYXJ0Lm5hbWVdOiB0b29sUmVzdWx0U3RyZWFtUGFydC5jb2RlLFxufSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IHZhbGlkQ29kZXMgPSBzdHJlYW1QYXJ0cy5tYXAocGFydCA9PiBwYXJ0LmNvZGUpO1xuXG4vKipcblBhcnNlcyBhIHN0cmVhbSBwYXJ0IGZyb20gYSBzdHJpbmcuXG5cbkBwYXJhbSBsaW5lIFRoZSBzdHJpbmcgdG8gcGFyc2UuXG5AcmV0dXJucyBUaGUgcGFyc2VkIHN0cmVhbSBwYXJ0LlxuQHRocm93cyBBbiBlcnJvciBpZiB0aGUgc3RyaW5nIGNhbm5vdCBiZSBwYXJzZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBwYXJzZVN0cmVhbVBhcnQgPSAobGluZTogc3RyaW5nKTogU3RyZWFtUGFydFR5cGUgPT4ge1xuICBjb25zdCBmaXJzdFNlcGFyYXRvckluZGV4ID0gbGluZS5pbmRleE9mKCc6Jyk7XG5cbiAgaWYgKGZpcnN0U2VwYXJhdG9ySW5kZXggPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcGFyc2Ugc3RyZWFtIHN0cmluZy4gTm8gc2VwYXJhdG9yIGZvdW5kLicpO1xuICB9XG5cbiAgY29uc3QgcHJlZml4ID0gbGluZS5zbGljZSgwLCBmaXJzdFNlcGFyYXRvckluZGV4KTtcblxuICBpZiAoIXZhbGlkQ29kZXMuaW5jbHVkZXMocHJlZml4IGFzIGtleW9mIHR5cGVvZiBzdHJlYW1QYXJ0c0J5Q29kZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBzdHJlYW0gc3RyaW5nLiBJbnZhbGlkIGNvZGUgJHtwcmVmaXh9LmApO1xuICB9XG5cbiAgY29uc3QgY29kZSA9IHByZWZpeCBhcyBrZXlvZiB0eXBlb2Ygc3RyZWFtUGFydHNCeUNvZGU7XG5cbiAgY29uc3QgdGV4dFZhbHVlID0gbGluZS5zbGljZShmaXJzdFNlcGFyYXRvckluZGV4ICsgMSk7XG4gIGNvbnN0IGpzb25WYWx1ZTogSlNPTlZhbHVlID0gSlNPTi5wYXJzZSh0ZXh0VmFsdWUpO1xuXG4gIHJldHVybiBzdHJlYW1QYXJ0c0J5Q29kZVtjb2RlXS5wYXJzZShqc29uVmFsdWUpO1xufTtcblxuLyoqXG5QcmVwZW5kcyBhIHN0cmluZyB3aXRoIGEgcHJlZml4IGZyb20gdGhlIGBTdHJlYW1DaHVua1ByZWZpeGVzYCwgSlNPTi1pZmllcyBpdCxcbmFuZCBhcHBlbmRzIGEgbmV3IGxpbmUuXG5cbkl0IGVuc3VyZXMgdHlwZS1zYWZldHkgZm9yIHRoZSBwYXJ0IHR5cGUgYW5kIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0U3RyZWFtUGFydDxUIGV4dGVuZHMga2V5b2YgU3RyZWFtUGFydFZhbHVlVHlwZT4oXG4gIHR5cGU6IFQsXG4gIHZhbHVlOiBTdHJlYW1QYXJ0VmFsdWVUeXBlW1RdLFxuKTogU3RyZWFtU3RyaW5nIHtcbiAgY29uc3Qgc3RyZWFtUGFydCA9IHN0cmVhbVBhcnRzLmZpbmQocGFydCA9PiBwYXJ0Lm5hbWUgPT09IHR5cGUpO1xuXG4gIGlmICghc3RyZWFtUGFydCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzdHJlYW0gcGFydCB0eXBlOiAke3R5cGV9YCk7XG4gIH1cblxuICByZXR1cm4gYCR7c3RyZWFtUGFydC5jb2RlfToke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1cXG5gO1xufVxuIiwiaW1wb3J0IHsgU3RyZWFtUGFydFR5cGUsIHBhcnNlU3RyZWFtUGFydCB9IGZyb20gJy4vc3RyZWFtLXBhcnRzJztcblxuY29uc3QgTkVXTElORSA9ICdcXG4nLmNoYXJDb2RlQXQoMCk7XG5cbi8vIGNvbmNhdGVuYXRlcyBhbGwgdGhlIGNodW5rcyBpbnRvIGEgc2luZ2xlIFVpbnQ4QXJyYXlcbmZ1bmN0aW9uIGNvbmNhdENodW5rcyhjaHVua3M6IFVpbnQ4QXJyYXlbXSwgdG90YWxMZW5ndGg6IG51bWJlcikge1xuICBjb25zdCBjb25jYXRlbmF0ZWRDaHVua3MgPSBuZXcgVWludDhBcnJheSh0b3RhbExlbmd0aCk7XG5cbiAgbGV0IG9mZnNldCA9IDA7XG4gIGZvciAoY29uc3QgY2h1bmsgb2YgY2h1bmtzKSB7XG4gICAgY29uY2F0ZW5hdGVkQ2h1bmtzLnNldChjaHVuaywgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gY2h1bmsubGVuZ3RoO1xuICB9XG4gIGNodW5rcy5sZW5ndGggPSAwO1xuXG4gIHJldHVybiBjb25jYXRlbmF0ZWRDaHVua3M7XG59XG5cbi8qKlxuQ29udmVydHMgYSBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIgaW50byBhbiBhc3luYyBnZW5lcmF0b3IgdGhhdCB5aWVsZHNcblN0cmVhbVBhcnQgb2JqZWN0cy5cblxuQHBhcmFtIHJlYWRlciBcbiAgICAgICBSZWFkZXIgZm9yIHRoZSBzdHJlYW0gdG8gcmVhZCBmcm9tLlxuQHBhcmFtIGlzQWJvcnRlZFxuICAgICAgIE9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIGlmIHRoZSByZXF1ZXN0IGhhcyBiZWVuIGFib3J0ZWQuXG4gICAgICAgSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSwgdGhlIGdlbmVyYXRvciB3aWxsIHN0b3AgcmVhZGluZyB0aGUgc3RyZWFtLlxuICAgICAgIElmIHRoZSBmdW5jdGlvbiBpcyBub3QgcHJvdmlkZWQsIHRoZSBnZW5lcmF0b3Igd2lsbCBub3Qgc3RvcCByZWFkaW5nIHRoZSBzdHJlYW0uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiogcmVhZERhdGFTdHJlYW0oXG4gIHJlYWRlcjogUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFVpbnQ4QXJyYXk+LFxuICB7XG4gICAgaXNBYm9ydGVkLFxuICB9OiB7XG4gICAgaXNBYm9ydGVkPzogKCkgPT4gYm9vbGVhbjtcbiAgfSA9IHt9LFxuKTogQXN5bmNHZW5lcmF0b3I8U3RyZWFtUGFydFR5cGU+IHtcbiAgLy8gaW1wbGVtZW50YXRpb24gbm90ZTogdGhpcyBzbGlnaHRseSBtb3JlIGNvbXBsZXggYWxnb3JpdGhtIGlzIHJlcXVpcmVkXG4gIC8vIHRvIHBhc3MgdGhlIHRlc3RzIGluIHRoZSBlZGdlIGVudmlyb25tZW50LlxuXG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgY29uc3QgY2h1bmtzOiBVaW50OEFycmF5W10gPSBbXTtcbiAgbGV0IHRvdGFsTGVuZ3RoID0gMDtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHsgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG5cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGNodW5rcy5wdXNoKHZhbHVlKTtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IHZhbHVlLmxlbmd0aDtcbiAgICAgIGlmICh2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSAhPT0gTkVXTElORSkge1xuICAgICAgICAvLyBpZiB0aGUgbGFzdCBjaGFyYWN0ZXIgaXMgbm90IGEgbmV3bGluZSwgd2UgaGF2ZSBub3QgcmVhZCB0aGUgd2hvbGUgSlNPTiB2YWx1ZVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2h1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgYnJlYWs7IC8vIHdlIGhhdmUgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBzdHJlYW1cbiAgICB9XG5cbiAgICBjb25zdCBjb25jYXRlbmF0ZWRDaHVua3MgPSBjb25jYXRDaHVua3MoY2h1bmtzLCB0b3RhbExlbmd0aCk7XG4gICAgdG90YWxMZW5ndGggPSAwO1xuXG4gICAgY29uc3Qgc3RyZWFtUGFydHMgPSBkZWNvZGVyXG4gICAgICAuZGVjb2RlKGNvbmNhdGVuYXRlZENodW5rcywgeyBzdHJlYW06IHRydWUgfSlcbiAgICAgIC5zcGxpdCgnXFxuJylcbiAgICAgIC5maWx0ZXIobGluZSA9PiBsaW5lICE9PSAnJykgLy8gc3BsaXR0aW5nIGxlYXZlcyBhbiBlbXB0eSBzdHJpbmcgYXQgdGhlIGVuZFxuICAgICAgLm1hcChwYXJzZVN0cmVhbVBhcnQpO1xuXG4gICAgZm9yIChjb25zdCBzdHJlYW1QYXJ0IG9mIHN0cmVhbVBhcnRzKSB7XG4gICAgICB5aWVsZCBzdHJlYW1QYXJ0O1xuICAgIH1cblxuICAgIC8vIFRoZSByZXF1ZXN0IGhhcyBiZWVuIGFib3J0ZWQsIHN0b3AgcmVhZGluZyB0aGUgc3RyZWFtLlxuICAgIGlmIChpc0Fib3J0ZWQ/LigpKSB7XG4gICAgICByZWFkZXIuY2FuY2VsKCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IGdlbmVyYXRlSWQgYXMgZ2VuZXJhdGVJZEZ1bmN0aW9uIH0gZnJvbSAnLi9nZW5lcmF0ZS1pZCc7XG5pbXBvcnQgeyByZWFkRGF0YVN0cmVhbSB9IGZyb20gJy4vcmVhZC1kYXRhLXN0cmVhbSc7XG5pbXBvcnQgdHlwZSB7IEZ1bmN0aW9uQ2FsbCwgSlNPTlZhbHVlLCBNZXNzYWdlLCBUb29sQ2FsbCB9IGZyb20gJy4vdHlwZXMnO1xuXG50eXBlIFByZWZpeE1hcCA9IHtcbiAgdGV4dD86IE1lc3NhZ2U7XG4gIGZ1bmN0aW9uX2NhbGw/OiBNZXNzYWdlICYge1xuICAgIHJvbGU6ICdhc3Npc3RhbnQnO1xuICAgIGZ1bmN0aW9uX2NhbGw6IEZ1bmN0aW9uQ2FsbDtcbiAgfTtcbiAgdG9vbF9jYWxscz86IE1lc3NhZ2UgJiB7XG4gICAgcm9sZTogJ2Fzc2lzdGFudCc7XG4gICAgdG9vbF9jYWxsczogVG9vbENhbGxbXTtcbiAgfTtcbiAgZGF0YTogSlNPTlZhbHVlW107XG59O1xuXG5mdW5jdGlvbiBhc3NpZ25Bbm5vdGF0aW9uc1RvTWVzc2FnZTxUIGV4dGVuZHMgTWVzc2FnZSB8IG51bGwgfCB1bmRlZmluZWQ+KFxuICBtZXNzYWdlOiBULFxuICBhbm5vdGF0aW9uczogSlNPTlZhbHVlW10gfCB1bmRlZmluZWQsXG4pOiBUIHtcbiAgaWYgKCFtZXNzYWdlIHx8ICFhbm5vdGF0aW9ucyB8fCAhYW5ub3RhdGlvbnMubGVuZ3RoKSByZXR1cm4gbWVzc2FnZTtcbiAgcmV0dXJuIHsgLi4ubWVzc2FnZSwgYW5ub3RhdGlvbnM6IFsuLi5hbm5vdGF0aW9uc10gfSBhcyBUO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcGFyc2VDb21wbGV4UmVzcG9uc2Uoe1xuICByZWFkZXIsXG4gIGFib3J0Q29udHJvbGxlclJlZixcbiAgdXBkYXRlLFxuICBvbkZpbmlzaCxcbiAgZ2VuZXJhdGVJZCA9IGdlbmVyYXRlSWRGdW5jdGlvbixcbiAgZ2V0Q3VycmVudERhdGUgPSAoKSA9PiBuZXcgRGF0ZSgpLFxufToge1xuICByZWFkZXI6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxVaW50OEFycmF5PjtcbiAgYWJvcnRDb250cm9sbGVyUmVmPzoge1xuICAgIGN1cnJlbnQ6IEFib3J0Q29udHJvbGxlciB8IG51bGw7XG4gIH07XG4gIHVwZGF0ZTogKG1lcmdlZDogTWVzc2FnZVtdLCBkYXRhOiBKU09OVmFsdWVbXSB8IHVuZGVmaW5lZCkgPT4gdm9pZDtcbiAgb25GaW5pc2g/OiAocHJlZml4TWFwOiBQcmVmaXhNYXApID0+IHZvaWQ7XG4gIGdlbmVyYXRlSWQ/OiAoKSA9PiBzdHJpbmc7XG4gIGdldEN1cnJlbnREYXRlPzogKCkgPT4gRGF0ZTtcbn0pIHtcbiAgY29uc3QgY3JlYXRlZEF0ID0gZ2V0Q3VycmVudERhdGUoKTtcbiAgY29uc3QgcHJlZml4TWFwOiBQcmVmaXhNYXAgPSB7XG4gICAgZGF0YTogW10sXG4gIH07XG5cbiAgLy8ga2VlcCBsaXN0IG9mIGN1cnJlbnQgbWVzc2FnZSBhbm5vdGF0aW9ucyBmb3IgbWVzc2FnZVxuICBsZXQgbWVzc2FnZV9hbm5vdGF0aW9uczogSlNPTlZhbHVlW10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5cbiAgLy8gd2UgY3JlYXRlIGEgbWFwIG9mIGVhY2ggcHJlZml4LCBhbmQgZm9yIGVhY2ggcHJlZml4ZWQgbWVzc2FnZSB3ZSBwdXNoIHRvIHRoZSBtYXBcbiAgZm9yIGF3YWl0IChjb25zdCB7IHR5cGUsIHZhbHVlIH0gb2YgcmVhZERhdGFTdHJlYW0ocmVhZGVyLCB7XG4gICAgaXNBYm9ydGVkOiAoKSA9PiBhYm9ydENvbnRyb2xsZXJSZWY/LmN1cnJlbnQgPT09IG51bGwsXG4gIH0pKSB7XG4gICAgaWYgKHR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgaWYgKHByZWZpeE1hcFsndGV4dCddKSB7XG4gICAgICAgIHByZWZpeE1hcFsndGV4dCddID0ge1xuICAgICAgICAgIC4uLnByZWZpeE1hcFsndGV4dCddLFxuICAgICAgICAgIGNvbnRlbnQ6IChwcmVmaXhNYXBbJ3RleHQnXS5jb250ZW50IHx8ICcnKSArIHZhbHVlLFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJlZml4TWFwWyd0ZXh0J10gPSB7XG4gICAgICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgICByb2xlOiAnYXNzaXN0YW50JyxcbiAgICAgICAgICBjb250ZW50OiB2YWx1ZSxcbiAgICAgICAgICBjcmVhdGVkQXQsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVG9vbCBpbnZvY2F0aW9ucyBhcmUgcGFydCBvZiBhbiBhc3Npc3RhbnQgbWVzc2FnZVxuICAgIGlmICh0eXBlID09PSAndG9vbF9jYWxsJykge1xuICAgICAgLy8gY3JlYXRlIG1lc3NhZ2UgaWYgaXQgZG9lc24ndCBleGlzdFxuICAgICAgaWYgKHByZWZpeE1hcC50ZXh0ID09IG51bGwpIHtcbiAgICAgICAgcHJlZml4TWFwLnRleHQgPSB7XG4gICAgICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgICByb2xlOiAnYXNzaXN0YW50JyxcbiAgICAgICAgICBjb250ZW50OiAnJyxcbiAgICAgICAgICBjcmVhdGVkQXQsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChwcmVmaXhNYXAudGV4dC50b29sSW52b2NhdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICBwcmVmaXhNYXAudGV4dC50b29sSW52b2NhdGlvbnMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgcHJlZml4TWFwLnRleHQudG9vbEludm9jYXRpb25zLnB1c2godmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3Rvb2xfcmVzdWx0Jykge1xuICAgICAgLy8gY3JlYXRlIG1lc3NhZ2UgaWYgaXQgZG9lc24ndCBleGlzdFxuICAgICAgaWYgKHByZWZpeE1hcC50ZXh0ID09IG51bGwpIHtcbiAgICAgICAgcHJlZml4TWFwLnRleHQgPSB7XG4gICAgICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgICByb2xlOiAnYXNzaXN0YW50JyxcbiAgICAgICAgICBjb250ZW50OiAnJyxcbiAgICAgICAgICBjcmVhdGVkQXQsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChwcmVmaXhNYXAudGV4dC50b29sSW52b2NhdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICBwcmVmaXhNYXAudGV4dC50b29sSW52b2NhdGlvbnMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgLy8gZmluZCBpZiB0aGVyZSBpcyBhbnkgdG9vbCBpbnZvY2F0aW9uIHdpdGggdGhlIHNhbWUgdG9vbENhbGxJZFxuICAgICAgLy8gYW5kIHJlcGxhY2UgaXQgd2l0aCB0aGUgcmVzdWx0XG4gICAgICBjb25zdCB0b29sSW52b2NhdGlvbkluZGV4ID0gcHJlZml4TWFwLnRleHQudG9vbEludm9jYXRpb25zLmZpbmRJbmRleChcbiAgICAgICAgaW52b2NhdGlvbiA9PiBpbnZvY2F0aW9uLnRvb2xDYWxsSWQgPT09IHZhbHVlLnRvb2xDYWxsSWQsXG4gICAgICApO1xuXG4gICAgICBpZiAodG9vbEludm9jYXRpb25JbmRleCAhPT0gLTEpIHtcbiAgICAgICAgcHJlZml4TWFwLnRleHQudG9vbEludm9jYXRpb25zW3Rvb2xJbnZvY2F0aW9uSW5kZXhdID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmVmaXhNYXAudGV4dC50b29sSW52b2NhdGlvbnMucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGZ1bmN0aW9uQ2FsbE1lc3NhZ2U6IE1lc3NhZ2UgfCBudWxsIHwgdW5kZWZpbmVkID0gbnVsbDtcblxuICAgIGlmICh0eXBlID09PSAnZnVuY3Rpb25fY2FsbCcpIHtcbiAgICAgIHByZWZpeE1hcFsnZnVuY3Rpb25fY2FsbCddID0ge1xuICAgICAgICBpZDogZ2VuZXJhdGVJZCgpLFxuICAgICAgICByb2xlOiAnYXNzaXN0YW50JyxcbiAgICAgICAgY29udGVudDogJycsXG4gICAgICAgIGZ1bmN0aW9uX2NhbGw6IHZhbHVlLmZ1bmN0aW9uX2NhbGwsXG4gICAgICAgIG5hbWU6IHZhbHVlLmZ1bmN0aW9uX2NhbGwubmFtZSxcbiAgICAgICAgY3JlYXRlZEF0LFxuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb25DYWxsTWVzc2FnZSA9IHByZWZpeE1hcFsnZnVuY3Rpb25fY2FsbCddO1xuICAgIH1cblxuICAgIGxldCB0b29sQ2FsbE1lc3NhZ2U6IE1lc3NhZ2UgfCBudWxsIHwgdW5kZWZpbmVkID0gbnVsbDtcblxuICAgIGlmICh0eXBlID09PSAndG9vbF9jYWxscycpIHtcbiAgICAgIHByZWZpeE1hcFsndG9vbF9jYWxscyddID0ge1xuICAgICAgICBpZDogZ2VuZXJhdGVJZCgpLFxuICAgICAgICByb2xlOiAnYXNzaXN0YW50JyxcbiAgICAgICAgY29udGVudDogJycsXG4gICAgICAgIHRvb2xfY2FsbHM6IHZhbHVlLnRvb2xfY2FsbHMsXG4gICAgICAgIGNyZWF0ZWRBdCxcbiAgICAgIH07XG5cbiAgICAgIHRvb2xDYWxsTWVzc2FnZSA9IHByZWZpeE1hcFsndG9vbF9jYWxscyddO1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAnZGF0YScpIHtcbiAgICAgIHByZWZpeE1hcFsnZGF0YSddLnB1c2goLi4udmFsdWUpO1xuICAgIH1cblxuICAgIGxldCByZXNwb25zZU1lc3NhZ2UgPSBwcmVmaXhNYXBbJ3RleHQnXTtcblxuICAgIGlmICh0eXBlID09PSAnbWVzc2FnZV9hbm5vdGF0aW9ucycpIHtcbiAgICAgIGlmICghbWVzc2FnZV9hbm5vdGF0aW9ucykge1xuICAgICAgICBtZXNzYWdlX2Fubm90YXRpb25zID0gWy4uLnZhbHVlXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lc3NhZ2VfYW5ub3RhdGlvbnMucHVzaCguLi52YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBhbnkgZXhpc3RpbmcgbWVzc2FnZSB3aXRoIHRoZSBsYXRlc3QgYW5ub3RhdGlvbnNcbiAgICAgIGZ1bmN0aW9uQ2FsbE1lc3NhZ2UgPSBhc3NpZ25Bbm5vdGF0aW9uc1RvTWVzc2FnZShcbiAgICAgICAgcHJlZml4TWFwWydmdW5jdGlvbl9jYWxsJ10sXG4gICAgICAgIG1lc3NhZ2VfYW5ub3RhdGlvbnMsXG4gICAgICApO1xuICAgICAgdG9vbENhbGxNZXNzYWdlID0gYXNzaWduQW5ub3RhdGlvbnNUb01lc3NhZ2UoXG4gICAgICAgIHByZWZpeE1hcFsndG9vbF9jYWxscyddLFxuICAgICAgICBtZXNzYWdlX2Fubm90YXRpb25zLFxuICAgICAgKTtcbiAgICAgIHJlc3BvbnNlTWVzc2FnZSA9IGFzc2lnbkFubm90YXRpb25zVG9NZXNzYWdlKFxuICAgICAgICBwcmVmaXhNYXBbJ3RleHQnXSxcbiAgICAgICAgbWVzc2FnZV9hbm5vdGF0aW9ucyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8ga2VlcHMgdGhlIHByZWZpeE1hcCB1cCB0byBkYXRlIHdpdGggdGhlIGxhdGVzdCBhbm5vdGF0aW9ucywgZXZlbiBpZiBhbm5vdGF0aW9ucyBwcmVjZWRlZCB0aGUgbWVzc2FnZVxuICAgIGlmIChtZXNzYWdlX2Fubm90YXRpb25zPy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2VQcmVmaXhLZXlzOiAoa2V5b2YgUHJlZml4TWFwKVtdID0gW1xuICAgICAgICAndGV4dCcsXG4gICAgICAgICdmdW5jdGlvbl9jYWxsJyxcbiAgICAgICAgJ3Rvb2xfY2FsbHMnLFxuICAgICAgXTtcbiAgICAgIG1lc3NhZ2VQcmVmaXhLZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgaWYgKHByZWZpeE1hcFtrZXldKSB7XG4gICAgICAgICAgKHByZWZpeE1hcFtrZXldIGFzIE1lc3NhZ2UpLmFubm90YXRpb25zID0gWy4uLm1lc3NhZ2VfYW5ub3RhdGlvbnMhXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gV2UgYWRkIGZ1bmN0aW9uICYgdG9vbCBjYWxscyBhbmQgcmVzcG9uc2UgbWVzc2FnZXMgdG8gdGhlIG1lc3NhZ2VzW10sIGJ1dCBkYXRhIGlzIGl0cyBvd24gdGhpbmdcbiAgICBjb25zdCBtZXJnZWQgPSBbZnVuY3Rpb25DYWxsTWVzc2FnZSwgdG9vbENhbGxNZXNzYWdlLCByZXNwb25zZU1lc3NhZ2VdXG4gICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAubWFwKG1lc3NhZ2UgPT4gKHtcbiAgICAgICAgLi4uYXNzaWduQW5ub3RhdGlvbnNUb01lc3NhZ2UobWVzc2FnZSwgbWVzc2FnZV9hbm5vdGF0aW9ucyksXG4gICAgICB9KSkgYXMgTWVzc2FnZVtdO1xuXG4gICAgdXBkYXRlKG1lcmdlZCwgWy4uLnByZWZpeE1hcFsnZGF0YSddXSk7IC8vIG1ha2UgYSBjb3B5IG9mIHRoZSBkYXRhIGFycmF5XG4gIH1cblxuICBvbkZpbmlzaD8uKHByZWZpeE1hcCk7XG5cbiAgcmV0dXJuIHtcbiAgICBtZXNzYWdlczogW1xuICAgICAgcHJlZml4TWFwLnRleHQsXG4gICAgICBwcmVmaXhNYXAuZnVuY3Rpb25fY2FsbCxcbiAgICAgIHByZWZpeE1hcC50b29sX2NhbGxzLFxuICAgIF0uZmlsdGVyKEJvb2xlYW4pIGFzIE1lc3NhZ2VbXSxcbiAgICBkYXRhOiBwcmVmaXhNYXAuZGF0YSxcbiAgfTtcbn1cbiIsImltcG9ydCB7XG4gIFN0cmVhbVBhcnRUeXBlLFxuICBTdHJlYW1TdHJpbmdQcmVmaXhlcyxcbiAgcGFyc2VTdHJlYW1QYXJ0LFxufSBmcm9tICcuL3N0cmVhbS1wYXJ0cyc7XG5cbmV4cG9ydCAqIGZyb20gJy4vZ2VuZXJhdGUtaWQnO1xuXG4vLyBUT0RPIHJlbW92ZSAoYnJlYWtpbmcgY2hhbmdlKVxuZXhwb3J0IHsgZ2VuZXJhdGVJZCBhcyBuYW5vaWQgfSBmcm9tICcuL2dlbmVyYXRlLWlkJztcblxuLy8gRXhwb3J0IHN0cmVhbSBkYXRhIHV0aWxpdGllcyBmb3IgY3VzdG9tIHN0cmVhbSBpbXBsZW1lbnRhdGlvbnMsXG4vLyBib3RoIG9uIHRoZSBjbGllbnQgYW5kIHNlcnZlciBzaWRlLlxuZXhwb3J0IHR5cGUgeyBTdHJlYW1QYXJ0IH0gZnJvbSAnLi9zdHJlYW0tcGFydHMnO1xuZXhwb3J0IHsgZm9ybWF0U3RyZWFtUGFydCwgcGFyc2VTdHJlYW1QYXJ0IH0gZnJvbSAnLi9zdHJlYW0tcGFydHMnO1xuZXhwb3J0IHsgcmVhZERhdGFTdHJlYW0gfSBmcm9tICcuL3JlYWQtZGF0YS1zdHJlYW0nO1xuXG4vLyBzaW1wbGUgZGVjb2RlciBzaWduYXR1cmVzOlxuZnVuY3Rpb24gY3JlYXRlQ2h1bmtEZWNvZGVyKCk6IChjaHVuazogVWludDhBcnJheSB8IHVuZGVmaW5lZCkgPT4gc3RyaW5nO1xuZnVuY3Rpb24gY3JlYXRlQ2h1bmtEZWNvZGVyKFxuICBjb21wbGV4OiBmYWxzZSxcbik6IChjaHVuazogVWludDhBcnJheSB8IHVuZGVmaW5lZCkgPT4gc3RyaW5nO1xuLy8gY29tcGxleCBkZWNvZGVyIHNpZ25hdHVyZTpcbmZ1bmN0aW9uIGNyZWF0ZUNodW5rRGVjb2RlcihcbiAgY29tcGxleDogdHJ1ZSxcbik6IChjaHVuazogVWludDhBcnJheSB8IHVuZGVmaW5lZCkgPT4gU3RyZWFtUGFydFR5cGVbXTtcbi8vIGNvbWJpbmVkIHNpZ25hdHVyZSBmb3Igd2hlbiB0aGUgY2xpZW50IGNhbGxzIHRoaXMgZnVuY3Rpb24gd2l0aCBhIGJvb2xlYW46XG5mdW5jdGlvbiBjcmVhdGVDaHVua0RlY29kZXIoXG4gIGNvbXBsZXg/OiBib29sZWFuLFxuKTogKGNodW5rOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkKSA9PiBTdHJlYW1QYXJ0VHlwZVtdIHwgc3RyaW5nO1xuZnVuY3Rpb24gY3JlYXRlQ2h1bmtEZWNvZGVyKGNvbXBsZXg/OiBib29sZWFuKSB7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcblxuICBpZiAoIWNvbXBsZXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNodW5rOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkKTogc3RyaW5nIHtcbiAgICAgIGlmICghY2h1bmspIHJldHVybiAnJztcbiAgICAgIHJldHVybiBkZWNvZGVyLmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoY2h1bms6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBkZWNvZGVkID0gZGVjb2RlclxuICAgICAgLmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSlcbiAgICAgIC5zcGxpdCgnXFxuJylcbiAgICAgIC5maWx0ZXIobGluZSA9PiBsaW5lICE9PSAnJyk7IC8vIHNwbGl0dGluZyBsZWF2ZXMgYW4gZW1wdHkgc3RyaW5nIGF0IHRoZSBlbmRcblxuICAgIHJldHVybiBkZWNvZGVkLm1hcChwYXJzZVN0cmVhbVBhcnQpLmZpbHRlcihCb29sZWFuKTtcbiAgfTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlQ2h1bmtEZWNvZGVyIH07XG5cbmV4cG9ydCBjb25zdCBpc1N0cmVhbVN0cmluZ0VxdWFsVG9UeXBlID0gKFxuICB0eXBlOiBrZXlvZiB0eXBlb2YgU3RyZWFtU3RyaW5nUHJlZml4ZXMsXG4gIHZhbHVlOiBzdHJpbmcsXG4pOiB2YWx1ZSBpcyBTdHJlYW1TdHJpbmcgPT5cbiAgdmFsdWUuc3RhcnRzV2l0aChgJHtTdHJlYW1TdHJpbmdQcmVmaXhlc1t0eXBlXX06YCkgJiYgdmFsdWUuZW5kc1dpdGgoJ1xcbicpO1xuXG5leHBvcnQgdHlwZSBTdHJlYW1TdHJpbmcgPVxuICBgJHsodHlwZW9mIFN0cmVhbVN0cmluZ1ByZWZpeGVzKVtrZXlvZiB0eXBlb2YgU3RyZWFtU3RyaW5nUHJlZml4ZXNdfToke3N0cmluZ31cXG5gO1xuIiwiaW1wb3J0IHsgcGFyc2VDb21wbGV4UmVzcG9uc2UgfSBmcm9tICcuL3BhcnNlLWNvbXBsZXgtcmVzcG9uc2UnO1xuaW1wb3J0IHsgSWRHZW5lcmF0b3IsIEpTT05WYWx1ZSwgTWVzc2FnZSB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgY3JlYXRlQ2h1bmtEZWNvZGVyIH0gZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjYWxsQ2hhdEFwaSh7XG4gIGFwaSxcbiAgbWVzc2FnZXMsXG4gIGJvZHksXG4gIHN0cmVhbU1vZGUgPSAnc3RyZWFtLWRhdGEnLFxuICBjcmVkZW50aWFscyxcbiAgaGVhZGVycyxcbiAgYWJvcnRDb250cm9sbGVyLFxuICByZXN0b3JlTWVzc2FnZXNPbkZhaWx1cmUsXG4gIG9uUmVzcG9uc2UsXG4gIG9uVXBkYXRlLFxuICBvbkZpbmlzaCxcbiAgZ2VuZXJhdGVJZCxcbn06IHtcbiAgYXBpOiBzdHJpbmc7XG4gIG1lc3NhZ2VzOiBPbWl0PE1lc3NhZ2UsICdpZCc+W107XG4gIGJvZHk6IFJlY29yZDxzdHJpbmcsIGFueT47XG4gIHN0cmVhbU1vZGU/OiAnc3RyZWFtLWRhdGEnIHwgJ3RleHQnO1xuICBjcmVkZW50aWFscz86IFJlcXVlc3RDcmVkZW50aWFscztcbiAgaGVhZGVycz86IEhlYWRlcnNJbml0O1xuICBhYm9ydENvbnRyb2xsZXI/OiAoKSA9PiBBYm9ydENvbnRyb2xsZXIgfCBudWxsO1xuICByZXN0b3JlTWVzc2FnZXNPbkZhaWx1cmU6ICgpID0+IHZvaWQ7XG4gIG9uUmVzcG9uc2U/OiAocmVzcG9uc2U6IFJlc3BvbnNlKSA9PiB2b2lkIHwgUHJvbWlzZTx2b2lkPjtcbiAgb25VcGRhdGU6IChtZXJnZWQ6IE1lc3NhZ2VbXSwgZGF0YTogSlNPTlZhbHVlW10gfCB1bmRlZmluZWQpID0+IHZvaWQ7XG4gIG9uRmluaXNoPzogKG1lc3NhZ2U6IE1lc3NhZ2UpID0+IHZvaWQ7XG4gIGdlbmVyYXRlSWQ6IElkR2VuZXJhdG9yO1xufSkge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGFwaSwge1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIG1lc3NhZ2VzLFxuICAgICAgLi4uYm9keSxcbiAgICB9KSxcbiAgICBoZWFkZXJzOiB7XG4gICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgLi4uaGVhZGVycyxcbiAgICB9LFxuICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyPy4oKT8uc2lnbmFsLFxuICAgIGNyZWRlbnRpYWxzLFxuICB9KS5jYXRjaChlcnIgPT4ge1xuICAgIHJlc3RvcmVNZXNzYWdlc09uRmFpbHVyZSgpO1xuICAgIHRocm93IGVycjtcbiAgfSk7XG5cbiAgaWYgKG9uUmVzcG9uc2UpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgb25SZXNwb25zZShyZXNwb25zZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgIHJlc3RvcmVNZXNzYWdlc09uRmFpbHVyZSgpO1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIChhd2FpdCByZXNwb25zZS50ZXh0KCkpIHx8ICdGYWlsZWQgdG8gZmV0Y2ggdGhlIGNoYXQgcmVzcG9uc2UuJyxcbiAgICApO1xuICB9XG5cbiAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcmVzcG9uc2UgYm9keSBpcyBlbXB0eS4nKTtcbiAgfVxuXG4gIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG5cbiAgc3dpdGNoIChzdHJlYW1Nb2RlKSB7XG4gICAgY2FzZSAndGV4dCc6IHtcbiAgICAgIGNvbnN0IGRlY29kZXIgPSBjcmVhdGVDaHVua0RlY29kZXIoKTtcblxuICAgICAgY29uc3QgcmVzdWx0TWVzc2FnZSA9IHtcbiAgICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgICByb2xlOiAnYXNzaXN0YW50JyBhcyBjb25zdCxcbiAgICAgICAgY29udGVudDogJycsXG4gICAgICB9O1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0TWVzc2FnZS5jb250ZW50ICs9IGRlY29kZXIodmFsdWUpO1xuICAgICAgICByZXN1bHRNZXNzYWdlLmlkID0gZ2VuZXJhdGVJZCgpO1xuXG4gICAgICAgIC8vIG5vdGU6IGNyZWF0aW5nIGEgbmV3IG1lc3NhZ2Ugb2JqZWN0IGlzIHJlcXVpcmVkIGZvciBTb2xpZC5qcyBzdHJlYW1pbmdcbiAgICAgICAgb25VcGRhdGUoW3sgLi4ucmVzdWx0TWVzc2FnZSB9XSwgW10pO1xuXG4gICAgICAgIC8vIFRoZSByZXF1ZXN0IGhhcyBiZWVuIGFib3J0ZWQsIHN0b3AgcmVhZGluZyB0aGUgc3RyZWFtLlxuICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyPy4oKSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlYWRlci5jYW5jZWwoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBvbkZpbmlzaD8uKHJlc3VsdE1lc3NhZ2UpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZXNzYWdlczogW3Jlc3VsdE1lc3NhZ2VdLFxuICAgICAgICBkYXRhOiBbXSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY2FzZSAnc3RyZWFtLWRhdGEnOiB7XG4gICAgICByZXR1cm4gYXdhaXQgcGFyc2VDb21wbGV4UmVzcG9uc2Uoe1xuICAgICAgICByZWFkZXIsXG4gICAgICAgIGFib3J0Q29udHJvbGxlclJlZjpcbiAgICAgICAgICBhYm9ydENvbnRyb2xsZXIgIT0gbnVsbCA/IHsgY3VycmVudDogYWJvcnRDb250cm9sbGVyKCkgfSA6IHVuZGVmaW5lZCxcbiAgICAgICAgdXBkYXRlOiBvblVwZGF0ZSxcbiAgICAgICAgb25GaW5pc2gocHJlZml4TWFwKSB7XG4gICAgICAgICAgaWYgKG9uRmluaXNoICYmIHByZWZpeE1hcC50ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG9uRmluaXNoKHByZWZpeE1hcC50ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdlbmVyYXRlSWQsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCBleGhhdXN0aXZlQ2hlY2s6IG5ldmVyID0gc3RyZWFtTW9kZTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzdHJlYW0gbW9kZTogJHtleGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQge1xuICBDaGF0UmVxdWVzdCxcbiAgRnVuY3Rpb25DYWxsLFxuICBKU09OVmFsdWUsXG4gIE1lc3NhZ2UsXG4gIFRvb2xDYWxsLFxufSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NDaGF0U3RyZWFtKHtcbiAgZ2V0U3RyZWFtZWRSZXNwb25zZSxcbiAgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsLFxuICBleHBlcmltZW50YWxfb25Ub29sQ2FsbCxcbiAgdXBkYXRlQ2hhdFJlcXVlc3QsXG4gIGdldEN1cnJlbnRNZXNzYWdlcyxcbn06IHtcbiAgZ2V0U3RyZWFtZWRSZXNwb25zZTogKCkgPT4gUHJvbWlzZTxcbiAgICBNZXNzYWdlIHwgeyBtZXNzYWdlczogTWVzc2FnZVtdOyBkYXRhOiBKU09OVmFsdWVbXSB9XG4gID47XG4gIGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbD86IChcbiAgICBjaGF0TWVzc2FnZXM6IE1lc3NhZ2VbXSxcbiAgICBmdW5jdGlvbkNhbGw6IEZ1bmN0aW9uQ2FsbCxcbiAgKSA9PiBQcm9taXNlPHZvaWQgfCBDaGF0UmVxdWVzdD47XG4gIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsPzogKFxuICAgIGNoYXRNZXNzYWdlczogTWVzc2FnZVtdLFxuICAgIHRvb2xDYWxsczogVG9vbENhbGxbXSxcbiAgKSA9PiBQcm9taXNlPHZvaWQgfCBDaGF0UmVxdWVzdD47XG4gIHVwZGF0ZUNoYXRSZXF1ZXN0OiAoY2hhdFJlcXVlc3Q6IENoYXRSZXF1ZXN0KSA9PiB2b2lkO1xuICBnZXRDdXJyZW50TWVzc2FnZXM6ICgpID0+IE1lc3NhZ2VbXTtcbn0pIHtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICAvLyBUT0RPLVNUUkVBTURBVEE6IFRoaXMgc2hvdWxkIGJlIHsgIGNvbnN0IHsgbWVzc2FnZXM6IHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlcywgZGF0YSB9ID1cbiAgICAvLyBhd2FpdCBnZXRTdHJlYW1lZFJlc3BvbnNlKH0gb25jZSBTdHJlYW0gRGF0YSBpcyBub3QgZXhwZXJpbWVudGFsXG4gICAgY29uc3QgbWVzc2FnZXNBbmREYXRhT3JKdXN0TWVzc2FnZSA9IGF3YWl0IGdldFN0cmVhbWVkUmVzcG9uc2UoKTtcblxuICAgIC8vIFVzaW5nIGV4cGVyaW1lbnRhbCBzdHJlYW0gZGF0YVxuICAgIGlmICgnbWVzc2FnZXMnIGluIG1lc3NhZ2VzQW5kRGF0YU9ySnVzdE1lc3NhZ2UpIHtcbiAgICAgIGxldCBoYXNGb2xsb3dpbmdSZXNwb25zZSA9IGZhbHNlO1xuXG4gICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgbWVzc2FnZXNBbmREYXRhT3JKdXN0TWVzc2FnZS5tZXNzYWdlcykge1xuICAgICAgICAvLyBTZWUgaWYgdGhlIG1lc3NhZ2UgaGFzIGEgY29tcGxldGUgZnVuY3Rpb24gY2FsbCBvciB0b29sIGNhbGxcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChtZXNzYWdlLmZ1bmN0aW9uX2NhbGwgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgdHlwZW9mIG1lc3NhZ2UuZnVuY3Rpb25fY2FsbCA9PT0gJ3N0cmluZycpICYmXG4gICAgICAgICAgKG1lc3NhZ2UudG9vbF9jYWxscyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICB0eXBlb2YgbWVzc2FnZS50b29sX2NhbGxzID09PSAnc3RyaW5nJylcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBoYXNGb2xsb3dpbmdSZXNwb25zZSA9IHRydWU7XG4gICAgICAgIC8vIFRyeSB0byBoYW5kbGUgZnVuY3Rpb24gY2FsbFxuICAgICAgICBpZiAoZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKSB7XG4gICAgICAgICAgY29uc3QgZnVuY3Rpb25DYWxsID0gbWVzc2FnZS5mdW5jdGlvbl9jYWxsO1xuICAgICAgICAgIC8vIE1ha2Ugc3VyZSBmdW5jdGlvbkNhbGwgaXMgYW4gb2JqZWN0XG4gICAgICAgICAgLy8gSWYgbm90LCB3ZSBnb3QgdG9vbCBjYWxscyBpbnN0ZWFkIG9mIGZ1bmN0aW9uIGNhbGxzXG4gICAgICAgICAgaWYgKHR5cGVvZiBmdW5jdGlvbkNhbGwgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICdleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgc2hvdWxkIG5vdCBiZSBkZWZpbmVkIHdoZW4gdXNpbmcgdG9vbHMnLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFVzZXIgaGFuZGxlcyB0aGUgZnVuY3Rpb24gY2FsbCBpbiB0aGVpciBvd24gZnVuY3Rpb25DYWxsSGFuZGxlci5cbiAgICAgICAgICAvLyBUaGUgXCJhcmd1bWVudHNcIiBrZXkgb2YgdGhlIGZ1bmN0aW9uIGNhbGwgb2JqZWN0IHdpbGwgc3RpbGwgYmUgYSBzdHJpbmcgd2hpY2ggd2lsbCBoYXZlIHRvIGJlIHBhcnNlZCBpbiB0aGUgZnVuY3Rpb24gaGFuZGxlci5cbiAgICAgICAgICAvLyBJZiB0aGUgXCJhcmd1bWVudHNcIiBKU09OIGlzIG1hbGZvcm1lZCBkdWUgdG8gbW9kZWwgZXJyb3IgdGhlIHVzZXIgd2lsbCBoYXZlIHRvIGhhbmRsZSB0aGF0IHRoZW1zZWx2ZXMuXG5cbiAgICAgICAgICBjb25zdCBmdW5jdGlvbkNhbGxSZXNwb25zZTogQ2hhdFJlcXVlc3QgfCB2b2lkID1cbiAgICAgICAgICAgIGF3YWl0IGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbChcbiAgICAgICAgICAgICAgZ2V0Q3VycmVudE1lc3NhZ2VzKCksXG4gICAgICAgICAgICAgIGZ1bmN0aW9uQ2FsbCxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBJZiB0aGUgdXNlciBkb2VzIG5vdCByZXR1cm4gYW55dGhpbmcgYXMgYSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uIGNhbGwsIHRoZSBsb29wIHdpbGwgYnJlYWsuXG4gICAgICAgICAgaWYgKGZ1bmN0aW9uQ2FsbFJlc3BvbnNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGhhc0ZvbGxvd2luZ1Jlc3BvbnNlID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBBIGZ1bmN0aW9uIGNhbGwgcmVzcG9uc2Ugd2FzIHJldHVybmVkLlxuICAgICAgICAgIC8vIFRoZSB1cGRhdGVkIGNoYXQgd2l0aCBmdW5jdGlvbiBjYWxsIHJlc3BvbnNlIHdpbGwgYmUgc2VudCB0byB0aGUgQVBJIGluIHRoZSBuZXh0IGl0ZXJhdGlvbiBvZiB0aGUgbG9vcC5cbiAgICAgICAgICB1cGRhdGVDaGF0UmVxdWVzdChmdW5jdGlvbkNhbGxSZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJ5IHRvIGhhbmRsZSB0b29sIGNhbGxcbiAgICAgICAgaWYgKGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKSB7XG4gICAgICAgICAgY29uc3QgdG9vbENhbGxzID0gbWVzc2FnZS50b29sX2NhbGxzO1xuICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0b29sQ2FsbHMgaXMgYW4gYXJyYXkgb2Ygb2JqZWN0c1xuICAgICAgICAgIC8vIElmIG5vdCwgd2UgZ290IGZ1bmN0aW9uIGNhbGxzIGluc3RlYWQgb2YgdG9vbCBjYWxsc1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFBcnJheS5pc0FycmF5KHRvb2xDYWxscykgfHxcbiAgICAgICAgICAgIHRvb2xDYWxscy5zb21lKHRvb2xDYWxsID0+IHR5cGVvZiB0b29sQ2FsbCAhPT0gJ29iamVjdCcpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICdleHBlcmltZW50YWxfb25Ub29sQ2FsbCBzaG91bGQgbm90IGJlIGRlZmluZWQgd2hlbiB1c2luZyB0b29scycsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVXNlciBoYW5kbGVzIHRoZSBmdW5jdGlvbiBjYWxsIGluIHRoZWlyIG93biBmdW5jdGlvbkNhbGxIYW5kbGVyLlxuICAgICAgICAgIC8vIFRoZSBcImFyZ3VtZW50c1wiIGtleSBvZiB0aGUgZnVuY3Rpb24gY2FsbCBvYmplY3Qgd2lsbCBzdGlsbCBiZSBhIHN0cmluZyB3aGljaCB3aWxsIGhhdmUgdG8gYmUgcGFyc2VkIGluIHRoZSBmdW5jdGlvbiBoYW5kbGVyLlxuICAgICAgICAgIC8vIElmIHRoZSBcImFyZ3VtZW50c1wiIEpTT04gaXMgbWFsZm9ybWVkIGR1ZSB0byBtb2RlbCBlcnJvciB0aGUgdXNlciB3aWxsIGhhdmUgdG8gaGFuZGxlIHRoYXQgdGhlbXNlbHZlcy5cbiAgICAgICAgICBjb25zdCB0b29sQ2FsbFJlc3BvbnNlOiBDaGF0UmVxdWVzdCB8IHZvaWQgPVxuICAgICAgICAgICAgYXdhaXQgZXhwZXJpbWVudGFsX29uVG9vbENhbGwoZ2V0Q3VycmVudE1lc3NhZ2VzKCksIHRvb2xDYWxscyk7XG5cbiAgICAgICAgICAvLyBJZiB0aGUgdXNlciBkb2VzIG5vdCByZXR1cm4gYW55dGhpbmcgYXMgYSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uIGNhbGwsIHRoZSBsb29wIHdpbGwgYnJlYWsuXG4gICAgICAgICAgaWYgKHRvb2xDYWxsUmVzcG9uc2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaGFzRm9sbG93aW5nUmVzcG9uc2UgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEEgZnVuY3Rpb24gY2FsbCByZXNwb25zZSB3YXMgcmV0dXJuZWQuXG4gICAgICAgICAgLy8gVGhlIHVwZGF0ZWQgY2hhdCB3aXRoIGZ1bmN0aW9uIGNhbGwgcmVzcG9uc2Ugd2lsbCBiZSBzZW50IHRvIHRoZSBBUEkgaW4gdGhlIG5leHQgaXRlcmF0aW9uIG9mIHRoZSBsb29wLlxuICAgICAgICAgIHVwZGF0ZUNoYXRSZXF1ZXN0KHRvb2xDYWxsUmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWhhc0ZvbGxvd2luZ1Jlc3BvbnNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZSA9IG1lc3NhZ2VzQW5kRGF0YU9ySnVzdE1lc3NhZ2U7XG5cbiAgICAgIC8vIFRPRE8tU1RSRUFNREFUQTogUmVtb3ZlIHRoaXMgb25jZSBTdHJlYW0gRGF0YSBpcyBub3QgZXhwZXJpbWVudGFsXG4gICAgICBpZiAoXG4gICAgICAgIChzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZS5mdW5jdGlvbl9jYWxsID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICB0eXBlb2Ygc3RyZWFtZWRSZXNwb25zZU1lc3NhZ2UuZnVuY3Rpb25fY2FsbCA9PT0gJ3N0cmluZycpICYmXG4gICAgICAgIChzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZS50b29sX2NhbGxzID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICB0eXBlb2Ygc3RyZWFtZWRSZXNwb25zZU1lc3NhZ2UudG9vbF9jYWxscyA9PT0gJ3N0cmluZycpXG4gICAgICApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHdlIGdldCBoZXJlIGFuZCBhcmUgZXhwZWN0aW5nIGEgZnVuY3Rpb24gY2FsbCwgdGhlIG1lc3NhZ2Ugc2hvdWxkIGhhdmUgb25lLCBpZiBub3Qgd2FybiBhbmQgY29udGludWVcbiAgICAgIGlmIChleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwpIHtcbiAgICAgICAgY29uc3QgZnVuY3Rpb25DYWxsID0gc3RyZWFtZWRSZXNwb25zZU1lc3NhZ2UuZnVuY3Rpb25fY2FsbDtcbiAgICAgICAgaWYgKCEodHlwZW9mIGZ1bmN0aW9uQ2FsbCA9PT0gJ29iamVjdCcpKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgJ2V4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCBzaG91bGQgbm90IGJlIGRlZmluZWQgd2hlbiB1c2luZyB0b29scycsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmdW5jdGlvbkNhbGxSZXNwb25zZTogQ2hhdFJlcXVlc3QgfCB2b2lkID1cbiAgICAgICAgICBhd2FpdCBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwoZ2V0Q3VycmVudE1lc3NhZ2VzKCksIGZ1bmN0aW9uQ2FsbCk7XG5cbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgZG9lcyBub3QgcmV0dXJuIGFueXRoaW5nIGFzIGEgcmVzdWx0IG9mIHRoZSBmdW5jdGlvbiBjYWxsLCB0aGUgbG9vcCB3aWxsIGJyZWFrLlxuICAgICAgICBpZiAoZnVuY3Rpb25DYWxsUmVzcG9uc2UgPT09IHVuZGVmaW5lZCkgYnJlYWs7XG4gICAgICAgIC8vIEEgZnVuY3Rpb24gY2FsbCByZXNwb25zZSB3YXMgcmV0dXJuZWQuXG4gICAgICAgIC8vIFRoZSB1cGRhdGVkIGNoYXQgd2l0aCBmdW5jdGlvbiBjYWxsIHJlc3BvbnNlIHdpbGwgYmUgc2VudCB0byB0aGUgQVBJIGluIHRoZSBuZXh0IGl0ZXJhdGlvbiBvZiB0aGUgbG9vcC5cbiAgICAgICAgZml4RnVuY3Rpb25DYWxsQXJndW1lbnRzKGZ1bmN0aW9uQ2FsbFJlc3BvbnNlKTtcbiAgICAgICAgdXBkYXRlQ2hhdFJlcXVlc3QoZnVuY3Rpb25DYWxsUmVzcG9uc2UpO1xuICAgICAgfVxuICAgICAgLy8gSWYgd2UgZ2V0IGhlcmUgYW5kIGFyZSBleHBlY3RpbmcgYSB0b29sIGNhbGwsIHRoZSBtZXNzYWdlIHNob3VsZCBoYXZlIG9uZSwgaWYgbm90IHdhcm4gYW5kIGNvbnRpbnVlXG4gICAgICBpZiAoZXhwZXJpbWVudGFsX29uVG9vbENhbGwpIHtcbiAgICAgICAgY29uc3QgdG9vbENhbGxzID0gc3RyZWFtZWRSZXNwb25zZU1lc3NhZ2UudG9vbF9jYWxscztcbiAgICAgICAgaWYgKCEodHlwZW9mIHRvb2xDYWxscyA9PT0gJ29iamVjdCcpKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgJ2V4cGVyaW1lbnRhbF9vblRvb2xDYWxsIHNob3VsZCBub3QgYmUgZGVmaW5lZCB3aGVuIHVzaW5nIGZ1bmN0aW9ucycsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b29sQ2FsbFJlc3BvbnNlOiBDaGF0UmVxdWVzdCB8IHZvaWQgPVxuICAgICAgICAgIGF3YWl0IGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKGdldEN1cnJlbnRNZXNzYWdlcygpLCB0b29sQ2FsbHMpO1xuXG4gICAgICAgIC8vIElmIHRoZSB1c2VyIGRvZXMgbm90IHJldHVybiBhbnl0aGluZyBhcyBhIHJlc3VsdCBvZiB0aGUgZnVuY3Rpb24gY2FsbCwgdGhlIGxvb3Agd2lsbCBicmVhay5cbiAgICAgICAgaWYgKHRvb2xDYWxsUmVzcG9uc2UgPT09IHVuZGVmaW5lZCkgYnJlYWs7XG4gICAgICAgIC8vIEEgZnVuY3Rpb24gY2FsbCByZXNwb25zZSB3YXMgcmV0dXJuZWQuXG4gICAgICAgIC8vIFRoZSB1cGRhdGVkIGNoYXQgd2l0aCBmdW5jdGlvbiBjYWxsIHJlc3BvbnNlIHdpbGwgYmUgc2VudCB0byB0aGUgQVBJIGluIHRoZSBuZXh0IGl0ZXJhdGlvbiBvZiB0aGUgbG9vcC5cbiAgICAgICAgZml4RnVuY3Rpb25DYWxsQXJndW1lbnRzKHRvb2xDYWxsUmVzcG9uc2UpO1xuICAgICAgICB1cGRhdGVDaGF0UmVxdWVzdCh0b29sQ2FsbFJlc3BvbnNlKTtcbiAgICAgIH1cblxuICAgICAgLy8gTWFrZSBzdXJlIGZ1bmN0aW9uIGNhbGwgYXJndW1lbnRzIGFyZSBzZW50IGJhY2sgdG8gdGhlIEFQSSBhcyBhIHN0cmluZ1xuICAgICAgZnVuY3Rpb24gZml4RnVuY3Rpb25DYWxsQXJndW1lbnRzKHJlc3BvbnNlOiBDaGF0UmVxdWVzdCkge1xuICAgICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgcmVzcG9uc2UubWVzc2FnZXMpIHtcbiAgICAgICAgICBpZiAobWVzc2FnZS50b29sX2NhbGxzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdG9vbENhbGwgb2YgbWVzc2FnZS50b29sX2NhbGxzKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgdG9vbENhbGwgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgdG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzICYmXG4gICAgICAgICAgICAgICAgICB0eXBlb2YgdG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzICE9PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgdG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzID0gSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgICAgIHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmZ1bmN0aW9uX2NhbGwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmZ1bmN0aW9uX2NhbGwgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIG1lc3NhZ2UuZnVuY3Rpb25fY2FsbC5hcmd1bWVudHMgIT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZnVuY3Rpb25fY2FsbC5hcmd1bWVudHMgPSBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZnVuY3Rpb25fY2FsbC5hcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlSWQsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlU1dSIGZyb20gJ3N3cic7XG5pbXBvcnQgeyBjYWxsQ29tcGxldGlvbkFwaSB9IGZyb20gJy4uL3NoYXJlZC9jYWxsLWNvbXBsZXRpb24tYXBpJztcbmltcG9ydCB7XG4gIEpTT05WYWx1ZSxcbiAgUmVxdWVzdE9wdGlvbnMsXG4gIFVzZUNvbXBsZXRpb25PcHRpb25zLFxufSBmcm9tICcuLi9zaGFyZWQvdHlwZXMnO1xuXG5leHBvcnQgdHlwZSB7IFVzZUNvbXBsZXRpb25PcHRpb25zIH07XG5cbmV4cG9ydCB0eXBlIFVzZUNvbXBsZXRpb25IZWxwZXJzID0ge1xuICAvKiogVGhlIGN1cnJlbnQgY29tcGxldGlvbiByZXN1bHQgKi9cbiAgY29tcGxldGlvbjogc3RyaW5nO1xuICAvKipcbiAgICogU2VuZCBhIG5ldyBwcm9tcHQgdG8gdGhlIEFQSSBlbmRwb2ludCBhbmQgdXBkYXRlIHRoZSBjb21wbGV0aW9uIHN0YXRlLlxuICAgKi9cbiAgY29tcGxldGU6IChcbiAgICBwcm9tcHQ6IHN0cmluZyxcbiAgICBvcHRpb25zPzogUmVxdWVzdE9wdGlvbnMsXG4gICkgPT4gUHJvbWlzZTxzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkPjtcbiAgLyoqIFRoZSBlcnJvciBvYmplY3Qgb2YgdGhlIEFQSSByZXF1ZXN0ICovXG4gIGVycm9yOiB1bmRlZmluZWQgfCBFcnJvcjtcbiAgLyoqXG4gICAqIEFib3J0IHRoZSBjdXJyZW50IEFQSSByZXF1ZXN0IGJ1dCBrZWVwIHRoZSBnZW5lcmF0ZWQgdG9rZW5zLlxuICAgKi9cbiAgc3RvcDogKCkgPT4gdm9pZDtcbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgYGNvbXBsZXRpb25gIHN0YXRlIGxvY2FsbHkuXG4gICAqL1xuICBzZXRDb21wbGV0aW9uOiAoY29tcGxldGlvbjogc3RyaW5nKSA9PiB2b2lkO1xuICAvKiogVGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGlucHV0ICovXG4gIGlucHV0OiBzdHJpbmc7XG4gIC8qKiBzZXRTdGF0ZS1wb3dlcmVkIG1ldGhvZCB0byB1cGRhdGUgdGhlIGlucHV0IHZhbHVlICovXG4gIHNldElucHV0OiBSZWFjdC5EaXNwYXRjaDxSZWFjdC5TZXRTdGF0ZUFjdGlvbjxzdHJpbmc+PjtcbiAgLyoqXG4gICAqIEFuIGlucHV0L3RleHRhcmVhLXJlYWR5IG9uQ2hhbmdlIGhhbmRsZXIgdG8gY29udHJvbCB0aGUgdmFsdWUgb2YgdGhlIGlucHV0XG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzeFxuICAgKiA8aW5wdXQgb25DaGFuZ2U9e2hhbmRsZUlucHV0Q2hhbmdlfSB2YWx1ZT17aW5wdXR9IC8+XG4gICAqIGBgYFxuICAgKi9cbiAgaGFuZGxlSW5wdXRDaGFuZ2U6IChcbiAgICBlOlxuICAgICAgfCBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PlxuICAgICAgfCBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MVGV4dEFyZWFFbGVtZW50PixcbiAgKSA9PiB2b2lkO1xuICAvKipcbiAgICogRm9ybSBzdWJtaXNzaW9uIGhhbmRsZXIgdG8gYXV0b21hdGljYWxseSByZXNldCBpbnB1dCBhbmQgYXBwZW5kIGEgdXNlciBtZXNzYWdlXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzeFxuICAgKiA8Zm9ybSBvblN1Ym1pdD17aGFuZGxlU3VibWl0fT5cbiAgICogIDxpbnB1dCBvbkNoYW5nZT17aGFuZGxlSW5wdXRDaGFuZ2V9IHZhbHVlPXtpbnB1dH0gLz5cbiAgICogPC9mb3JtPlxuICAgKiBgYGBcbiAgICovXG4gIGhhbmRsZVN1Ym1pdDogKGU6IFJlYWN0LkZvcm1FdmVudDxIVE1MRm9ybUVsZW1lbnQ+KSA9PiB2b2lkO1xuICAvKiogV2hldGhlciB0aGUgQVBJIHJlcXVlc3QgaXMgaW4gcHJvZ3Jlc3MgKi9cbiAgaXNMb2FkaW5nOiBib29sZWFuO1xuICAvKiogQWRkaXRpb25hbCBkYXRhIGFkZGVkIG9uIHRoZSBzZXJ2ZXIgdmlhIFN0cmVhbURhdGEgKi9cbiAgZGF0YT86IEpTT05WYWx1ZVtdO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNvbXBsZXRpb24oe1xuICBhcGkgPSAnL2FwaS9jb21wbGV0aW9uJyxcbiAgaWQsXG4gIGluaXRpYWxDb21wbGV0aW9uID0gJycsXG4gIGluaXRpYWxJbnB1dCA9ICcnLFxuICBjcmVkZW50aWFscyxcbiAgaGVhZGVycyxcbiAgYm9keSxcbiAgc3RyZWFtTW9kZSxcbiAgb25SZXNwb25zZSxcbiAgb25GaW5pc2gsXG4gIG9uRXJyb3IsXG59OiBVc2VDb21wbGV0aW9uT3B0aW9ucyA9IHt9KTogVXNlQ29tcGxldGlvbkhlbHBlcnMge1xuICAvLyBHZW5lcmF0ZSBhbiB1bmlxdWUgaWQgZm9yIHRoZSBjb21wbGV0aW9uIGlmIG5vdCBwcm92aWRlZC5cbiAgY29uc3QgaG9va0lkID0gdXNlSWQoKTtcbiAgY29uc3QgY29tcGxldGlvbklkID0gaWQgfHwgaG9va0lkO1xuXG4gIC8vIFN0b3JlIHRoZSBjb21wbGV0aW9uIHN0YXRlIGluIFNXUiwgdXNpbmcgdGhlIGNvbXBsZXRpb25JZCBhcyB0aGUga2V5IHRvIHNoYXJlIHN0YXRlcy5cbiAgY29uc3QgeyBkYXRhLCBtdXRhdGUgfSA9IHVzZVNXUjxzdHJpbmc+KFthcGksIGNvbXBsZXRpb25JZF0sIG51bGwsIHtcbiAgICBmYWxsYmFja0RhdGE6IGluaXRpYWxDb21wbGV0aW9uLFxuICB9KTtcblxuICBjb25zdCB7IGRhdGE6IGlzTG9hZGluZyA9IGZhbHNlLCBtdXRhdGU6IG11dGF0ZUxvYWRpbmcgfSA9IHVzZVNXUjxib29sZWFuPihcbiAgICBbY29tcGxldGlvbklkLCAnbG9hZGluZyddLFxuICAgIG51bGwsXG4gICk7XG5cbiAgY29uc3QgeyBkYXRhOiBzdHJlYW1EYXRhLCBtdXRhdGU6IG11dGF0ZVN0cmVhbURhdGEgfSA9IHVzZVNXUjxcbiAgICBKU09OVmFsdWVbXSB8IHVuZGVmaW5lZFxuICA+KFtjb21wbGV0aW9uSWQsICdzdHJlYW1EYXRhJ10sIG51bGwpO1xuXG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8dW5kZWZpbmVkIHwgRXJyb3I+KHVuZGVmaW5lZCk7XG4gIGNvbnN0IGNvbXBsZXRpb24gPSBkYXRhITtcblxuICAvLyBBYm9ydCBjb250cm9sbGVyIHRvIGNhbmNlbCB0aGUgY3VycmVudCBBUEkgY2FsbC5cbiAgY29uc3QgW2Fib3J0Q29udHJvbGxlciwgc2V0QWJvcnRDb250cm9sbGVyXSA9XG4gICAgdXNlU3RhdGU8QWJvcnRDb250cm9sbGVyIHwgbnVsbD4obnVsbCk7XG5cbiAgY29uc3QgZXh0cmFNZXRhZGF0YVJlZiA9IHVzZVJlZih7XG4gICAgY3JlZGVudGlhbHMsXG4gICAgaGVhZGVycyxcbiAgICBib2R5LFxuICB9KTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBleHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQgPSB7XG4gICAgICBjcmVkZW50aWFscyxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBib2R5LFxuICAgIH07XG4gIH0sIFtjcmVkZW50aWFscywgaGVhZGVycywgYm9keV0pO1xuXG4gIGNvbnN0IHRyaWdnZXJSZXF1ZXN0ID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKHByb21wdDogc3RyaW5nLCBvcHRpb25zPzogUmVxdWVzdE9wdGlvbnMpID0+XG4gICAgICBjYWxsQ29tcGxldGlvbkFwaSh7XG4gICAgICAgIGFwaSxcbiAgICAgICAgcHJvbXB0LFxuICAgICAgICBjcmVkZW50aWFsczogZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LmNyZWRlbnRpYWxzLFxuICAgICAgICBoZWFkZXJzOiB7IC4uLmV4dHJhTWV0YWRhdGFSZWYuY3VycmVudC5oZWFkZXJzLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAuLi5leHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQuYm9keSxcbiAgICAgICAgICAuLi5vcHRpb25zPy5ib2R5LFxuICAgICAgICB9LFxuICAgICAgICBzdHJlYW1Nb2RlLFxuICAgICAgICBzZXRDb21wbGV0aW9uOiBjb21wbGV0aW9uID0+IG11dGF0ZShjb21wbGV0aW9uLCBmYWxzZSksXG4gICAgICAgIHNldExvYWRpbmc6IG11dGF0ZUxvYWRpbmcsXG4gICAgICAgIHNldEVycm9yLFxuICAgICAgICBzZXRBYm9ydENvbnRyb2xsZXIsXG4gICAgICAgIG9uUmVzcG9uc2UsXG4gICAgICAgIG9uRmluaXNoLFxuICAgICAgICBvbkVycm9yLFxuICAgICAgICBvbkRhdGE6IGRhdGEgPT4ge1xuICAgICAgICAgIG11dGF0ZVN0cmVhbURhdGEoWy4uLihzdHJlYW1EYXRhIHx8IFtdKSwgLi4uKGRhdGEgfHwgW10pXSwgZmFsc2UpO1xuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgW1xuICAgICAgbXV0YXRlLFxuICAgICAgbXV0YXRlTG9hZGluZyxcbiAgICAgIGFwaSxcbiAgICAgIGV4dHJhTWV0YWRhdGFSZWYsXG4gICAgICBzZXRBYm9ydENvbnRyb2xsZXIsXG4gICAgICBvblJlc3BvbnNlLFxuICAgICAgb25GaW5pc2gsXG4gICAgICBvbkVycm9yLFxuICAgICAgc2V0RXJyb3IsXG4gICAgICBzdHJlYW1EYXRhLFxuICAgICAgc3RyZWFtTW9kZSxcbiAgICAgIG11dGF0ZVN0cmVhbURhdGEsXG4gICAgXSxcbiAgKTtcblxuICBjb25zdCBzdG9wID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChhYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgc2V0QWJvcnRDb250cm9sbGVyKG51bGwpO1xuICAgIH1cbiAgfSwgW2Fib3J0Q29udHJvbGxlcl0pO1xuXG4gIGNvbnN0IHNldENvbXBsZXRpb24gPSB1c2VDYWxsYmFjayhcbiAgICAoY29tcGxldGlvbjogc3RyaW5nKSA9PiB7XG4gICAgICBtdXRhdGUoY29tcGxldGlvbiwgZmFsc2UpO1xuICAgIH0sXG4gICAgW211dGF0ZV0sXG4gICk7XG5cbiAgY29uc3QgY29tcGxldGUgPSB1c2VDYWxsYmFjazxVc2VDb21wbGV0aW9uSGVscGVyc1snY29tcGxldGUnXT4oXG4gICAgYXN5bmMgKHByb21wdCwgb3B0aW9ucykgPT4ge1xuICAgICAgcmV0dXJuIHRyaWdnZXJSZXF1ZXN0KHByb21wdCwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBbdHJpZ2dlclJlcXVlc3RdLFxuICApO1xuXG4gIGNvbnN0IFtpbnB1dCwgc2V0SW5wdXRdID0gdXNlU3RhdGUoaW5pdGlhbElucHV0KTtcblxuICBjb25zdCBoYW5kbGVTdWJtaXQgPSB1c2VDYWxsYmFjayhcbiAgICAoZTogUmVhY3QuRm9ybUV2ZW50PEhUTUxGb3JtRWxlbWVudD4pID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGlmICghaW5wdXQpIHJldHVybjtcbiAgICAgIHJldHVybiBjb21wbGV0ZShpbnB1dCk7XG4gICAgfSxcbiAgICBbaW5wdXQsIGNvbXBsZXRlXSxcbiAgKTtcblxuICBjb25zdCBoYW5kbGVJbnB1dENoYW5nZSA9IChlOiBhbnkpID0+IHtcbiAgICBzZXRJbnB1dChlLnRhcmdldC52YWx1ZSk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBjb21wbGV0aW9uLFxuICAgIGNvbXBsZXRlLFxuICAgIGVycm9yLFxuICAgIHNldENvbXBsZXRpb24sXG4gICAgc3RvcCxcbiAgICBpbnB1dCxcbiAgICBzZXRJbnB1dCxcbiAgICBoYW5kbGVJbnB1dENoYW5nZSxcbiAgICBoYW5kbGVTdWJtaXQsXG4gICAgaXNMb2FkaW5nLFxuICAgIGRhdGE6IHN0cmVhbURhdGEsXG4gIH07XG59XG4iLCJpbXBvcnQgeyByZWFkRGF0YVN0cmVhbSB9IGZyb20gJy4vcmVhZC1kYXRhLXN0cmVhbSc7XG5pbXBvcnQgeyBKU09OVmFsdWUgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IGNyZWF0ZUNodW5rRGVjb2RlciB9IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FsbENvbXBsZXRpb25BcGkoe1xuICBhcGksXG4gIHByb21wdCxcbiAgY3JlZGVudGlhbHMsXG4gIGhlYWRlcnMsXG4gIGJvZHksXG4gIHN0cmVhbU1vZGUgPSAnc3RyZWFtLWRhdGEnLFxuICBzZXRDb21wbGV0aW9uLFxuICBzZXRMb2FkaW5nLFxuICBzZXRFcnJvcixcbiAgc2V0QWJvcnRDb250cm9sbGVyLFxuICBvblJlc3BvbnNlLFxuICBvbkZpbmlzaCxcbiAgb25FcnJvcixcbiAgb25EYXRhLFxufToge1xuICBhcGk6IHN0cmluZztcbiAgcHJvbXB0OiBzdHJpbmc7XG4gIGNyZWRlbnRpYWxzPzogUmVxdWVzdENyZWRlbnRpYWxzO1xuICBoZWFkZXJzPzogSGVhZGVyc0luaXQ7XG4gIGJvZHk6IFJlY29yZDxzdHJpbmcsIGFueT47XG4gIHN0cmVhbU1vZGU/OiAnc3RyZWFtLWRhdGEnIHwgJ3RleHQnO1xuICBzZXRDb21wbGV0aW9uOiAoY29tcGxldGlvbjogc3RyaW5nKSA9PiB2b2lkO1xuICBzZXRMb2FkaW5nOiAobG9hZGluZzogYm9vbGVhbikgPT4gdm9pZDtcbiAgc2V0RXJyb3I6IChlcnJvcjogRXJyb3IgfCB1bmRlZmluZWQpID0+IHZvaWQ7XG4gIHNldEFib3J0Q29udHJvbGxlcjogKGFib3J0Q29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyIHwgbnVsbCkgPT4gdm9pZDtcbiAgb25SZXNwb25zZT86IChyZXNwb25zZTogUmVzcG9uc2UpID0+IHZvaWQgfCBQcm9taXNlPHZvaWQ+O1xuICBvbkZpbmlzaD86IChwcm9tcHQ6IHN0cmluZywgY29tcGxldGlvbjogc3RyaW5nKSA9PiB2b2lkO1xuICBvbkVycm9yPzogKGVycm9yOiBFcnJvcikgPT4gdm9pZDtcbiAgb25EYXRhPzogKGRhdGE6IEpTT05WYWx1ZVtdKSA9PiB2b2lkO1xufSkge1xuICB0cnkge1xuICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgc2V0RXJyb3IodW5kZWZpbmVkKTtcblxuICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBzZXRBYm9ydENvbnRyb2xsZXIoYWJvcnRDb250cm9sbGVyKTtcblxuICAgIC8vIEVtcHR5IHRoZSBjb21wbGV0aW9uIGltbWVkaWF0ZWx5LlxuICAgIHNldENvbXBsZXRpb24oJycpO1xuXG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYXBpLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgcHJvbXB0LFxuICAgICAgICAuLi5ib2R5LFxuICAgICAgfSksXG4gICAgICBjcmVkZW50aWFscyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgLi4uaGVhZGVycyxcbiAgICAgIH0sXG4gICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9KTtcblxuICAgIGlmIChvblJlc3BvbnNlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBvblJlc3BvbnNlKHJlcyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIChhd2FpdCByZXMudGV4dCgpKSB8fCAnRmFpbGVkIHRvIGZldGNoIHRoZSBjaGF0IHJlc3BvbnNlLicsXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghcmVzLmJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHJlc3BvbnNlIGJvZHkgaXMgZW1wdHkuJyk7XG4gICAgfVxuXG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgIGNvbnN0IHJlYWRlciA9IHJlcy5ib2R5LmdldFJlYWRlcigpO1xuXG4gICAgc3dpdGNoIChzdHJlYW1Nb2RlKSB7XG4gICAgICBjYXNlICd0ZXh0Jzoge1xuICAgICAgICBjb25zdCBkZWNvZGVyID0gY3JlYXRlQ2h1bmtEZWNvZGVyKCk7XG5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIGNvbXBsZXRpb24gc3RhdGUgd2l0aCB0aGUgbmV3IG1lc3NhZ2UgdG9rZW5zLlxuICAgICAgICAgIHJlc3VsdCArPSBkZWNvZGVyKHZhbHVlKTtcbiAgICAgICAgICBzZXRDb21wbGV0aW9uKHJlc3VsdCk7XG5cbiAgICAgICAgICAvLyBUaGUgcmVxdWVzdCBoYXMgYmVlbiBhYm9ydGVkLCBzdG9wIHJlYWRpbmcgdGhlIHN0cmVhbS5cbiAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZWFkZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY2FzZSAnc3RyZWFtLWRhdGEnOiB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgeyB0eXBlLCB2YWx1ZSB9IG9mIHJlYWREYXRhU3RyZWFtKHJlYWRlciwge1xuICAgICAgICAgIGlzQWJvcnRlZDogKCkgPT4gYWJvcnRDb250cm9sbGVyID09PSBudWxsLFxuICAgICAgICB9KSkge1xuICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAndGV4dCc6IHtcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IHZhbHVlO1xuICAgICAgICAgICAgICBzZXRDb21wbGV0aW9uKHJlc3VsdCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnZGF0YSc6IHtcbiAgICAgICAgICAgICAgb25EYXRhPy4odmFsdWUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrOiBuZXZlciA9IHN0cmVhbU1vZGU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzdHJlYW0gbW9kZTogJHtleGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9uRmluaXNoKSB7XG4gICAgICBvbkZpbmlzaChwcm9tcHQsIHJlc3VsdCk7XG4gICAgfVxuXG4gICAgc2V0QWJvcnRDb250cm9sbGVyKG51bGwpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIElnbm9yZSBhYm9ydCBlcnJvcnMgYXMgdGhleSBhcmUgZXhwZWN0ZWQuXG4gICAgaWYgKChlcnIgYXMgYW55KS5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgIHNldEFib3J0Q29udHJvbGxlcihudWxsKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNldEVycm9yKGVyciBhcyBFcnJvcik7XG4gIH0gZmluYWxseSB7XG4gICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gIH1cbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzICovXG5cbmltcG9ydCB7IGlzQWJvcnRFcnJvciB9IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXItdXRpbHMnO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSAnLi4vc2hhcmVkL2dlbmVyYXRlLWlkJztcbmltcG9ydCB7IHJlYWREYXRhU3RyZWFtIH0gZnJvbSAnLi4vc2hhcmVkL3JlYWQtZGF0YS1zdHJlYW0nO1xuaW1wb3J0IHtcbiAgQXNzaXN0YW50U3RhdHVzLFxuICBDcmVhdGVNZXNzYWdlLFxuICBNZXNzYWdlLFxuICBVc2VBc3Npc3RhbnRPcHRpb25zLFxufSBmcm9tICcuLi9zaGFyZWQvdHlwZXMnO1xuXG5leHBvcnQgdHlwZSBVc2VBc3Npc3RhbnRIZWxwZXJzID0ge1xuICAvKipcbiAgICogVGhlIGN1cnJlbnQgYXJyYXkgb2YgY2hhdCBtZXNzYWdlcy5cbiAgICovXG4gIG1lc3NhZ2VzOiBNZXNzYWdlW107XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgbWVzc2FnZSBzdG9yZSB3aXRoIGEgbmV3IGFycmF5IG9mIG1lc3NhZ2VzLlxuICAgKi9cbiAgc2V0TWVzc2FnZXM6IFJlYWN0LkRpc3BhdGNoPFJlYWN0LlNldFN0YXRlQWN0aW9uPE1lc3NhZ2VbXT4+O1xuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCB0aHJlYWQgSUQuXG4gICAqL1xuICB0aHJlYWRJZDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgaW5wdXQgZmllbGQuXG4gICAqL1xuICBpbnB1dDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBcHBlbmQgYSB1c2VyIG1lc3NhZ2UgdG8gdGhlIGNoYXQgbGlzdC4gVGhpcyB0cmlnZ2VycyB0aGUgQVBJIGNhbGwgdG8gZmV0Y2hcbiAgICogdGhlIGFzc2lzdGFudCdzIHJlc3BvbnNlLlxuICAgKiBAcGFyYW0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBhcHBlbmRcbiAgICogQHBhcmFtIHJlcXVlc3RPcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBBUEkgY2FsbFxuICAgKi9cbiAgYXBwZW5kOiAoXG4gICAgbWVzc2FnZTogTWVzc2FnZSB8IENyZWF0ZU1lc3NhZ2UsXG4gICAgcmVxdWVzdE9wdGlvbnM/OiB7XG4gICAgICBkYXRhPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgICB9LFxuICApID0+IFByb21pc2U8dm9pZD47XG5cbiAgLyoqXG5BYm9ydCB0aGUgY3VycmVudCByZXF1ZXN0IGltbWVkaWF0ZWx5LCBrZWVwIHRoZSBnZW5lcmF0ZWQgdG9rZW5zIGlmIGFueS5cbiAgICovXG4gIHN0b3A6ICgpID0+IHZvaWQ7XG5cbiAgLyoqXG4gICAqIHNldFN0YXRlLXBvd2VyZWQgbWV0aG9kIHRvIHVwZGF0ZSB0aGUgaW5wdXQgdmFsdWUuXG4gICAqL1xuICBzZXRJbnB1dDogUmVhY3QuRGlzcGF0Y2g8UmVhY3QuU2V0U3RhdGVBY3Rpb248c3RyaW5nPj47XG5cbiAgLyoqXG4gICAqIEhhbmRsZXIgZm9yIHRoZSBgb25DaGFuZ2VgIGV2ZW50IG9mIHRoZSBpbnB1dCBmaWVsZCB0byBjb250cm9sIHRoZSBpbnB1dCdzIHZhbHVlLlxuICAgKi9cbiAgaGFuZGxlSW5wdXRDaGFuZ2U6IChcbiAgICBldmVudDpcbiAgICAgIHwgUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD5cbiAgICAgIHwgUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTFRleHRBcmVhRWxlbWVudD4sXG4gICkgPT4gdm9pZDtcblxuICAvKipcbiAgICogRm9ybSBzdWJtaXNzaW9uIGhhbmRsZXIgdGhhdCBhdXRvbWF0aWNhbGx5IHJlc2V0cyB0aGUgaW5wdXQgZmllbGQgYW5kIGFwcGVuZHMgYSB1c2VyIG1lc3NhZ2UuXG4gICAqL1xuICBzdWJtaXRNZXNzYWdlOiAoXG4gICAgZXZlbnQ/OiBSZWFjdC5Gb3JtRXZlbnQ8SFRNTEZvcm1FbGVtZW50PixcbiAgICByZXF1ZXN0T3B0aW9ucz86IHtcbiAgICAgIGRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICAgIH0sXG4gICkgPT4gUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgc3RhdHVzIG9mIHRoZSBhc3Npc3RhbnQuIFRoaXMgY2FuIGJlIHVzZWQgdG8gc2hvdyBhIGxvYWRpbmcgaW5kaWNhdG9yLlxuICAgKi9cbiAgc3RhdHVzOiBBc3Npc3RhbnRTdGF0dXM7XG5cbiAgLyoqXG4gICAqIFRoZSBlcnJvciB0aHJvd24gZHVyaW5nIHRoZSBhc3Npc3RhbnQgbWVzc2FnZSBwcm9jZXNzaW5nLCBpZiBhbnkuXG4gICAqL1xuICBlcnJvcjogdW5kZWZpbmVkIHwgdW5rbm93bjtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VBc3Npc3RhbnQoe1xuICBhcGksXG4gIHRocmVhZElkOiB0aHJlYWRJZFBhcmFtLFxuICBjcmVkZW50aWFscyxcbiAgaGVhZGVycyxcbiAgYm9keSxcbiAgb25FcnJvcixcbn06IFVzZUFzc2lzdGFudE9wdGlvbnMpOiBVc2VBc3Npc3RhbnRIZWxwZXJzIHtcbiAgY29uc3QgW21lc3NhZ2VzLCBzZXRNZXNzYWdlc10gPSB1c2VTdGF0ZTxNZXNzYWdlW10+KFtdKTtcbiAgY29uc3QgW2lucHV0LCBzZXRJbnB1dF0gPSB1c2VTdGF0ZSgnJyk7XG4gIGNvbnN0IFt0aHJlYWRJZCwgc2V0VGhyZWFkSWRdID0gdXNlU3RhdGU8c3RyaW5nIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xuICBjb25zdCBbc3RhdHVzLCBzZXRTdGF0dXNdID0gdXNlU3RhdGU8QXNzaXN0YW50U3RhdHVzPignYXdhaXRpbmdfbWVzc2FnZScpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHVuZGVmaW5lZCB8IEVycm9yPih1bmRlZmluZWQpO1xuXG4gIGNvbnN0IGhhbmRsZUlucHV0Q2hhbmdlID0gKFxuICAgIGV2ZW50OlxuICAgICAgfCBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PlxuICAgICAgfCBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MVGV4dEFyZWFFbGVtZW50PixcbiAgKSA9PiB7XG4gICAgc2V0SW5wdXQoZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgfTtcblxuICAvLyBBYm9ydCBjb250cm9sbGVyIHRvIGNhbmNlbCB0aGUgY3VycmVudCBBUEkgY2FsbC5cbiAgY29uc3QgYWJvcnRDb250cm9sbGVyUmVmID0gdXNlUmVmPEFib3J0Q29udHJvbGxlciB8IG51bGw+KG51bGwpO1xuXG4gIGNvbnN0IHN0b3AgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50KSB7XG4gICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudC5hYm9ydCgpO1xuICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIGNvbnN0IGFwcGVuZCA9IGFzeW5jIChcbiAgICBtZXNzYWdlOiBNZXNzYWdlIHwgQ3JlYXRlTWVzc2FnZSxcbiAgICByZXF1ZXN0T3B0aW9ucz86IHtcbiAgICAgIGRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICAgIH0sXG4gICkgPT4ge1xuICAgIHNldFN0YXR1cygnaW5fcHJvZ3Jlc3MnKTtcblxuICAgIHNldE1lc3NhZ2VzKG1lc3NhZ2VzID0+IFtcbiAgICAgIC4uLm1lc3NhZ2VzLFxuICAgICAge1xuICAgICAgICAuLi5tZXNzYWdlLFxuICAgICAgICBpZDogbWVzc2FnZS5pZCA/PyBnZW5lcmF0ZUlkKCksXG4gICAgICB9LFxuICAgIF0pO1xuXG4gICAgc2V0SW5wdXQoJycpO1xuXG4gICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50ID0gYWJvcnRDb250cm9sbGVyO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmZXRjaChhcGksIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGNyZWRlbnRpYWxzLFxuICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJywgLi4uaGVhZGVycyB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgLi4uYm9keSxcbiAgICAgICAgICAvLyBhbHdheXMgdXNlIHVzZXItcHJvdmlkZWQgdGhyZWFkSWQgd2hlbiBhdmFpbGFibGU6XG4gICAgICAgICAgdGhyZWFkSWQ6IHRocmVhZElkUGFyYW0gPz8gdGhyZWFkSWQgPz8gbnVsbCxcbiAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLmNvbnRlbnQsXG5cbiAgICAgICAgICAvLyBvcHRpb25hbCByZXF1ZXN0IGRhdGE6XG4gICAgICAgICAgZGF0YTogcmVxdWVzdE9wdGlvbnM/LmRhdGEsXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChyZXN1bHQuYm9keSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHJlc3BvbnNlIGJvZHkgaXMgZW1wdHkuJyk7XG4gICAgICB9XG5cbiAgICAgIGZvciBhd2FpdCAoY29uc3QgeyB0eXBlLCB2YWx1ZSB9IG9mIHJlYWREYXRhU3RyZWFtKFxuICAgICAgICByZXN1bHQuYm9keS5nZXRSZWFkZXIoKSxcbiAgICAgICkpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSAnYXNzaXN0YW50X21lc3NhZ2UnOiB7XG4gICAgICAgICAgICBzZXRNZXNzYWdlcyhtZXNzYWdlcyA9PiBbXG4gICAgICAgICAgICAgIC4uLm1lc3NhZ2VzLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWQ6IHZhbHVlLmlkLFxuICAgICAgICAgICAgICAgIHJvbGU6IHZhbHVlLnJvbGUsXG4gICAgICAgICAgICAgICAgY29udGVudDogdmFsdWUuY29udGVudFswXS50ZXh0LnZhbHVlLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICd0ZXh0Jzoge1xuICAgICAgICAgICAgLy8gdGV4dCBkZWx0YSAtIGFkZCB0byBsYXN0IG1lc3NhZ2U6XG4gICAgICAgICAgICBzZXRNZXNzYWdlcyhtZXNzYWdlcyA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGxhc3RNZXNzYWdlID0gbWVzc2FnZXNbbWVzc2FnZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgLi4ubWVzc2FnZXMuc2xpY2UoMCwgbWVzc2FnZXMubGVuZ3RoIC0gMSksXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWQ6IGxhc3RNZXNzYWdlLmlkLFxuICAgICAgICAgICAgICAgICAgcm9sZTogbGFzdE1lc3NhZ2Uucm9sZSxcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGxhc3RNZXNzYWdlLmNvbnRlbnQgKyB2YWx1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2RhdGFfbWVzc2FnZSc6IHtcbiAgICAgICAgICAgIHNldE1lc3NhZ2VzKG1lc3NhZ2VzID0+IFtcbiAgICAgICAgICAgICAgLi4ubWVzc2FnZXMsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZDogdmFsdWUuaWQgPz8gZ2VuZXJhdGVJZCgpLFxuICAgICAgICAgICAgICAgIHJvbGU6ICdkYXRhJyxcbiAgICAgICAgICAgICAgICBjb250ZW50OiAnJyxcbiAgICAgICAgICAgICAgICBkYXRhOiB2YWx1ZS5kYXRhLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdhc3Npc3RhbnRfY29udHJvbF9kYXRhJzoge1xuICAgICAgICAgICAgc2V0VGhyZWFkSWQodmFsdWUudGhyZWFkSWQpO1xuXG4gICAgICAgICAgICAvLyBzZXQgaWQgb2YgbGFzdCBtZXNzYWdlOlxuICAgICAgICAgICAgc2V0TWVzc2FnZXMobWVzc2FnZXMgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBsYXN0TWVzc2FnZSA9IG1lc3NhZ2VzW21lc3NhZ2VzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICBsYXN0TWVzc2FnZS5pZCA9IHZhbHVlLm1lc3NhZ2VJZDtcbiAgICAgICAgICAgICAgcmV0dXJuIFsuLi5tZXNzYWdlcy5zbGljZSgwLCBtZXNzYWdlcy5sZW5ndGggLSAxKSwgbGFzdE1lc3NhZ2VdO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2Vycm9yJzoge1xuICAgICAgICAgICAgc2V0RXJyb3IobmV3IEVycm9yKHZhbHVlKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gSWdub3JlIGFib3J0IGVycm9ycyBhcyB0aGV5IGFyZSBleHBlY3RlZCB3aGVuIHRoZSB1c2VyIGNhbmNlbHMgdGhlIHJlcXVlc3Q6XG4gICAgICBpZiAoaXNBYm9ydEVycm9yKGVycm9yKSAmJiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChvbkVycm9yICYmIGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIHNldEVycm9yKGVycm9yIGFzIEVycm9yKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgc2V0U3RhdHVzKCdhd2FpdGluZ19tZXNzYWdlJyk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHN1Ym1pdE1lc3NhZ2UgPSBhc3luYyAoXG4gICAgZXZlbnQ/OiBSZWFjdC5Gb3JtRXZlbnQ8SFRNTEZvcm1FbGVtZW50PixcbiAgICByZXF1ZXN0T3B0aW9ucz86IHtcbiAgICAgIGRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICAgIH0sXG4gICkgPT4ge1xuICAgIGV2ZW50Py5wcmV2ZW50RGVmYXVsdD8uKCk7XG5cbiAgICBpZiAoaW5wdXQgPT09ICcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYXBwZW5kKHsgcm9sZTogJ3VzZXInLCBjb250ZW50OiBpbnB1dCB9LCByZXF1ZXN0T3B0aW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBhcHBlbmQsXG4gICAgbWVzc2FnZXMsXG4gICAgc2V0TWVzc2FnZXMsXG4gICAgdGhyZWFkSWQsXG4gICAgaW5wdXQsXG4gICAgc2V0SW5wdXQsXG4gICAgaGFuZGxlSW5wdXRDaGFuZ2UsXG4gICAgc3VibWl0TWVzc2FnZSxcbiAgICBzdGF0dXMsXG4gICAgZXJyb3IsXG4gICAgc3RvcCxcbiAgfTtcbn1cblxuLyoqXG5AZGVwcmVjYXRlZCBVc2UgYHVzZUFzc2lzdGFudGAgaW5zdGVhZC5cbiAqL1xuZXhwb3J0IGNvbnN0IGV4cGVyaW1lbnRhbF91c2VBc3Npc3RhbnQgPSB1c2VBc3Npc3RhbnQ7XG4iXSwibmFtZXMiOlsidXNlQ2FsbGJhY2siLCJ1c2VFZmZlY3QiLCJ1c2VJZCIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlU1dSIiwiY3VzdG9tQWxwaGFiZXQiLCJnZW5lcmF0ZUlkIiwidGV4dFN0cmVhbVBhcnQiLCJjb2RlIiwibmFtZSIsInBhcnNlIiwidmFsdWUiLCJFcnJvciIsInR5cGUiLCJmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0IiwiZnVuY3Rpb25fY2FsbCIsImFyZ3VtZW50cyIsImRhdGFTdHJlYW1QYXJ0IiwiQXJyYXkiLCJpc0FycmF5IiwiZXJyb3JTdHJlYW1QYXJ0IiwiYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQiLCJpZCIsInJvbGUiLCJjb250ZW50IiwiZXZlcnkiLCJpdGVtIiwidGV4dCIsImFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydCIsInRocmVhZElkIiwibWVzc2FnZUlkIiwiZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0IiwidG9vbENhbGxzU3RyZWFtUGFydCIsInRvb2xfY2FsbHMiLCJzb21lIiwidGMiLCJmdW5jdGlvbiIsIm1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQiLCJ0b29sQ2FsbFN0cmVhbVBhcnQiLCJ0b29sQ2FsbElkIiwidG9vbE5hbWUiLCJhcmdzIiwidG9vbFJlc3VsdFN0cmVhbVBhcnQiLCJzdHJlYW1QYXJ0cyIsInN0cmVhbVBhcnRzQnlDb2RlIiwiU3RyZWFtU3RyaW5nUHJlZml4ZXMiLCJ2YWxpZENvZGVzIiwibWFwIiwicGFydCIsInBhcnNlU3RyZWFtUGFydCIsImxpbmUiLCJmaXJzdFNlcGFyYXRvckluZGV4IiwiaW5kZXhPZiIsInByZWZpeCIsInNsaWNlIiwiaW5jbHVkZXMiLCJ0ZXh0VmFsdWUiLCJqc29uVmFsdWUiLCJKU09OIiwiTkVXTElORSIsImNoYXJDb2RlQXQiLCJjb25jYXRDaHVua3MiLCJjaHVua3MiLCJ0b3RhbExlbmd0aCIsImNvbmNhdGVuYXRlZENodW5rcyIsIlVpbnQ4QXJyYXkiLCJvZmZzZXQiLCJjaHVuayIsInNldCIsImxlbmd0aCIsInJlYWREYXRhU3RyZWFtIiwicmVhZGVyIiwiaXNBYm9ydGVkIiwiZGVjb2RlciIsIlRleHREZWNvZGVyIiwicmVhZCIsInB1c2giLCJkZWNvZGUiLCJzdHJlYW0iLCJzcGxpdCIsImZpbHRlciIsInN0cmVhbVBhcnQiLCJjYW5jZWwiLCJhc3NpZ25Bbm5vdGF0aW9uc1RvTWVzc2FnZSIsIm1lc3NhZ2UiLCJhbm5vdGF0aW9ucyIsInBhcnNlQ29tcGxleFJlc3BvbnNlIiwiYWJvcnRDb250cm9sbGVyUmVmIiwidXBkYXRlIiwib25GaW5pc2giLCJnZXRDdXJyZW50RGF0ZSIsIkRhdGUiLCJjcmVhdGVkQXQiLCJwcmVmaXhNYXAiLCJkYXRhIiwibWVzc2FnZV9hbm5vdGF0aW9ucyIsImN1cnJlbnQiLCJ0b29sSW52b2NhdGlvbnMiLCJ0b29sSW52b2NhdGlvbkluZGV4IiwiZmluZEluZGV4IiwiaW52b2NhdGlvbiIsImZ1bmN0aW9uQ2FsbE1lc3NhZ2UiLCJ0b29sQ2FsbE1lc3NhZ2UiLCJyZXNwb25zZU1lc3NhZ2UiLCJtZXNzYWdlUHJlZml4S2V5cyIsImZvckVhY2giLCJrZXkiLCJtZXJnZWQiLCJCb29sZWFuIiwibWVzc2FnZXMiLCJjcmVhdGVDaHVua0RlY29kZXIiLCJjb21wbGV4IiwiZGVjb2RlZCIsImNhbGxDaGF0QXBpIiwiYXBpIiwiYm9keSIsInN0cmVhbU1vZGUiLCJjcmVkZW50aWFscyIsImhlYWRlcnMiLCJhYm9ydENvbnRyb2xsZXIiLCJyZXN0b3JlTWVzc2FnZXNPbkZhaWx1cmUiLCJvblJlc3BvbnNlIiwib25VcGRhdGUiLCJfYSIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJzdHJpbmdpZnkiLCJzaWduYWwiLCJjYXRjaCIsImVyciIsIm9rIiwiZ2V0UmVhZGVyIiwicmVzdWx0TWVzc2FnZSIsImRvbmUiLCJleGhhdXN0aXZlQ2hlY2siLCJwcm9jZXNzQ2hhdFN0cmVhbSIsImdldFN0cmVhbWVkUmVzcG9uc2UiLCJleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwiLCJleHBlcmltZW50YWxfb25Ub29sQ2FsbCIsInVwZGF0ZUNoYXRSZXF1ZXN0IiwiZ2V0Q3VycmVudE1lc3NhZ2VzIiwibWVzc2FnZXNBbmREYXRhT3JKdXN0TWVzc2FnZSIsImhhc0ZvbGxvd2luZ1Jlc3BvbnNlIiwiZnVuY3Rpb25DYWxsIiwiY29uc29sZSIsIndhcm4iLCJmdW5jdGlvbkNhbGxSZXNwb25zZSIsInRvb2xDYWxscyIsInRvb2xDYWxsIiwidG9vbENhbGxSZXNwb25zZSIsImZpeEZ1bmN0aW9uQ2FsbEFyZ3VtZW50cyIsInN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlIiwiY2hhdFJlcXVlc3QiLCJtdXRhdGUiLCJtdXRhdGVTdHJlYW1EYXRhIiwiZXhpc3RpbmdEYXRhIiwiZXh0cmFNZXRhZGF0YVJlZiIsIm1lc3NhZ2VzUmVmIiwic2VuZEV4dHJhTWVzc2FnZUZpZWxkcyIsIl9iIiwicHJldmlvdXNNZXNzYWdlcyIsImNvbnN0cnVjdGVkTWVzc2FnZXNQYXlsb2FkIiwidG9vbF9jYWxsX2lkIiwicmVwbHlJZCIsInJlYWRSb3ciLCJwcm9taXNlIiwidWkiLCJuZXh0IiwiZSIsIm9wdGlvbnMiLCJmdW5jdGlvbnMiLCJ0b29scyIsInRvb2xfY2hvaWNlIiwidXNlQ2hhdCIsImluaXRpYWxNZXNzYWdlcyIsImluaXRpYWxJbnB1dCIsImV4cGVyaW1lbnRhbF9tYXhBdXRvbWF0aWNSb3VuZHRyaXBzIiwib25FcnJvciIsImhvb2tJZCIsImlkS2V5IiwiY2hhdEtleSIsImluaXRpYWxNZXNzYWdlc0ZhbGxiYWNrIiwiZmFsbGJhY2tEYXRhIiwiaXNMb2FkaW5nIiwibXV0YXRlTG9hZGluZyIsInN0cmVhbURhdGEiLCJlcnJvciIsInNldEVycm9yIiwidHJpZ2dlclJlcXVlc3QiLCJBYm9ydENvbnRyb2xsZXIiLCJjaGF0UmVxdWVzdFBhcmFtIiwibGFzdE1lc3NhZ2UiLCJpc0Fzc2lzdGFudE1lc3NhZ2VXaXRoQ29tcGxldGVkVG9vbENhbGxzIiwiY291bnRUcmFpbGluZ0Fzc2lzdGFudE1lc3NhZ2VzIiwiYXBwZW5kIiwiY29uY2F0IiwicmVsb2FkIiwic3RvcCIsImFib3J0Iiwic2V0TWVzc2FnZXMiLCJpbnB1dCIsInNldElucHV0IiwiaGFuZGxlU3VibWl0IiwibWV0YWRhdGEiLCJwcmV2ZW50RGVmYXVsdCIsImhhbmRsZUlucHV0Q2hhbmdlIiwidGFyZ2V0IiwiZXhwZXJpbWVudGFsX2FkZFRvb2xSZXN1bHQiLCJyZXN1bHQiLCJ1cGRhdGVkTWVzc2FnZXMiLCJpbmRleCIsImFyciIsInRvb2xJbnZvY2F0aW9uIiwiY291bnQiLCJpIiwiY2FsbENvbXBsZXRpb25BcGkiLCJwcm9tcHQiLCJzZXRDb21wbGV0aW9uIiwic2V0TG9hZGluZyIsInNldEFib3J0Q29udHJvbGxlciIsIm9uRGF0YSIsInJlcyIsInVzZUNvbXBsZXRpb24iLCJpbml0aWFsQ29tcGxldGlvbiIsImNvbXBsZXRpb25JZCIsImNvbXBsZXRpb24iLCJjb21wbGV0ZSIsImlzQWJvcnRFcnJvciIsInVzZUFzc2lzdGFudCIsInRocmVhZElkUGFyYW0iLCJzZXRUaHJlYWRJZCIsInN0YXR1cyIsInNldFN0YXR1cyIsImV2ZW50IiwicmVxdWVzdE9wdGlvbnMiLCJhYm9ydGVkIiwic3VibWl0TWVzc2FnZSIsImNhbGwiLCJleHBlcmltZW50YWxfdXNlQXNzaXN0YW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ai/react/dist/index.mjs\n");

/***/ })

};
;